<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Massachusetts Building Analysis Dashboard - NSI-Enhanced USA Structures Dataset</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --secondary-gradient: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            --success-gradient: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            --warning-gradient: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            --dark-gradient: linear-gradient(135deg, #30cfd0 0%, #330867 100%);
            --soil-gradient: linear-gradient(135deg, #8B4513 0%, #D2691E 100%);
        }
        
        /* Modern Theme (Default) */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--primary-gradient);
            min-height: 100vh;
            padding: 20px;
            color: #333;
            transition: all 0.3s ease;
        }
        
        /* Professional Theme */
        body.professional-theme {
            background: #f5f5f5;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease;
        }
        
        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 20px;
            box-shadow: 0 25px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            animation: slideIn 0.6s ease;
            transition: all 0.3s ease;
        }
        
        .professional-theme .container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            animation: none;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .header {
            background: var(--primary-gradient);
            color: white;
            padding: 50px 40px;
            text-align: center;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .professional-theme .header {
            background: #2c3e50;
            padding: 30px 40px;
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            animation: pulse 4s ease-in-out infinite;
        }
        
        .professional-theme .header::before {
            display: none;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.1); opacity: 0.3; }
        }
        
        .header h1 {
            font-size: 2.8em;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
            position: relative;
            z-index: 1;
        }
        
        .professional-theme .header h1 {
            font-size: 2.2em;
            text-shadow: none;
            font-weight: 400;
        }
        
        .header p {
            font-size: 1.2em;
            opacity: 0.95;
            position: relative;
            z-index: 1;
        }
        
        .professional-theme .header p {
            font-size: 1em;
            opacity: 0.9;
        }
        
        .dataset-badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 16px;
            border-radius: 20px;
            margin-top: 10px;
            font-size: 0.9em;
            backdrop-filter: blur(10px);
        }
        
        .professional-theme .dataset-badge {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            backdrop-filter: none;
        }
        
        .nav-container {
            background: white;
            padding: 25px 20px;
            border-bottom: 2px solid #f0f0f0;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }
        
        .professional-theme .nav-container {
            padding: 15px 20px;
            border-bottom: 1px solid #ddd;
            box-shadow: none;
        }
        
        .nav-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
        }
        
        .nav-tab {
            padding: 14px 28px;
            background: #f5f5f5;
            border: 2px solid transparent;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 15px;
            font-weight: 600;
            color: #555;
            position: relative;
            overflow: hidden;
        }
        
        .professional-theme .nav-tab {
            padding: 10px 20px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-weight: 500;
        }
        
        .nav-tab::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: var(--primary-gradient);
            transition: left 0.3s ease;
            z-index: -1;
        }
        
        .professional-theme .nav-tab::before {
            display: none;
        }
        
        .nav-tab:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }
        
        .professional-theme .nav-tab:hover {
            transform: none;
            background: #f8f9fa;
            box-shadow: none;
        }
        
        .nav-tab:hover::before {
            left: 0;
        }
        
        .nav-tab:hover {
            color: white;
        }
        
        .professional-theme .nav-tab:hover {
            color: #333;
        }
        
        .nav-tab.active {
            background: var(--primary-gradient);
            color: white;
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }
        
        .professional-theme .nav-tab.active {
            background: #2c3e50;
            color: white;
            box-shadow: none;
            border-color: #2c3e50;
        }
        
        /* Special style for Soil Analysis tab */
        .nav-tab.soil-tab.active {
            background: var(--soil-gradient);
        }
        
        .content {
            padding: 40px;
            min-height: 600px;
        }
        
        .section {
            display: none;
            animation: fadeIn 0.5s ease;
        }
        
        .professional-theme .section {
            animation: none;
        }
        
        .section.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { 
                opacity: 0;
                transform: translateY(20px);
            }
            to { 
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .section-header {
            margin-bottom: 35px;
            padding-bottom: 20px;
            border-bottom: 3px solid #f0f0f0;
            position: relative;
        }
        
        .professional-theme .section-header {
            border-bottom: 2px solid #e0e0e0;
        }
        
        .section-header::after {
            content: '';
            position: absolute;
            bottom: -3px;
            left: 0;
            width: 100px;
            height: 3px;
            background: var(--primary-gradient);
        }
        
        .professional-theme .section-header::after {
            background: #2c3e50;
            height: 2px;
            bottom: -2px;
        }
        
        .section-header h2 {
            color: #333;
            font-size: 2.2em;
            margin-bottom: 12px;
        }
        
        .professional-theme .section-header h2 {
            font-size: 1.8em;
            font-weight: 500;
        }
        
        .section-header p {
            color: #666;
            font-size: 1.15em;
            line-height: 1.6;
        }
        
        .professional-theme .section-header p {
            font-size: 1em;
        }
        
        .controls {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.05);
        }
        
        .professional-theme .controls {
            background: #f8f9fa;
            border-radius: 4px;
            padding: 20px;
            box-shadow: none;
            border: 1px solid #dee2e6;
        }
        
        .control-group {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .control-group:last-child {
            margin-bottom: 0;
        }
        
        .control-group label {
            font-weight: 700;
            color: #495057;
            min-width: 120px;
        }
        
        .professional-theme .control-group label {
            font-weight: 600;
        }
        
        .control-group select,
        .control-group input {
            padding: 10px 18px;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            font-size: 15px;
            transition: all 0.3s ease;
            background: white;
            min-width: 150px;
        }
        
        .professional-theme .control-group select,
        .professional-theme .control-group input {
            border: 1px solid #ced4da;
            border-radius: 4px;
            padding: 8px 12px;
        }
        
        .control-group select:focus,
        .control-group input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .professional-theme .control-group select:focus,
        .professional-theme .control-group input:focus {
            border-color: #2c3e50;
            box-shadow: none;
        }
        
        .control-button {
            padding: 12px 28px;
            background: var(--primary-gradient);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 700;
            font-size: 15px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        .professional-theme .control-button {
            background: #2c3e50;
            border-radius: 4px;
            padding: 10px 20px;
            font-weight: 600;
            box-shadow: none;
        }
        
        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        
        .professional-theme .control-button:hover {
            transform: none;
            background: #34495e;
            box-shadow: none;
        }
        
        .control-button:active {
            transform: translateY(0);
        }
        
        .toggle-switch {
            display: inline-flex;
            align-items: center;
            gap: 10px;
        }
        
        .toggle-switch input[type="checkbox"] {
            width: 50px;
            height: 26px;
            appearance: none;
            background: #ddd;
            border-radius: 13px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .toggle-switch input[type="checkbox"]:checked {
            background: #667eea;
        }
        
        .professional-theme .toggle-switch input[type="checkbox"]:checked {
            background: #2c3e50;
        }
        
        .toggle-switch input[type="checkbox"]::after {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: white;
            top: 2px;
            left: 2px;
            transition: left 0.3s;
        }
        
        .toggle-switch input[type="checkbox"]:checked::after {
            left: 26px;
        }
        
        .chart-container {
            background: white;
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.08);
            transition: transform 0.3s ease;
        }
        
        .professional-theme .chart-container {
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            padding: 25px;
        }
        
        .chart-container:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
        }
        
        .professional-theme .chart-container:hover {
            transform: none;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
            margin-bottom: 35px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            transition: all 0.3s ease;
            color: white;
            position: relative;
            overflow: hidden;
        }
        
        .professional-theme .stat-card {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 25px;
            color: #333;
        }
        
        .stat-card::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.2) 0%, transparent 70%);
            animation: rotate 10s linear infinite;
        }
        
        .professional-theme .stat-card::before {
            display: none;
        }
        
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .stat-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 12px 30px rgba(102, 126, 234, 0.3);
        }
        
        .professional-theme .stat-card:hover {
            transform: none;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .stat-card:nth-child(2) {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        
        .professional-theme .stat-card:nth-child(2) {
            background: white;
        }
        
        .stat-card:nth-child(3) {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }
        
        .professional-theme .stat-card:nth-child(3) {
            background: white;
        }
        
        .stat-card:nth-child(4) {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }
        
        .professional-theme .stat-card:nth-child(4) {
            background: white;
        }
        
        /* Soil-specific stat cards */
        .stat-card.soil-card {
            background: var(--soil-gradient);
        }
        
        .professional-theme .stat-card.soil-card {
            background: white;
            border-color: #8B4513;
        }
        
        .stat-value {
            font-size: 3em;
            font-weight: 800;
            margin-bottom: 8px;
            position: relative;
            z-index: 1;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .professional-theme .stat-value {
            font-size: 2.5em;
            font-weight: 600;
            text-shadow: none;
            color: #2c3e50;
        }
        
        .stat-label {
            font-size: 1.1em;
            opacity: 0.95;
            position: relative;
            z-index: 1;
            font-weight: 600;
        }
        
        .professional-theme .stat-label {
            opacity: 1;
            font-weight: 500;
            color: #6c757d;
        }
        
        .info-box {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            padding: 25px;
            border-radius: 15px;
            border-left: 5px solid #2196f3;
            margin-bottom: 25px;
            position: relative;
            overflow: hidden;
        }
        
        .professional-theme .info-box {
            background: #f0f8ff;
            border-radius: 4px;
            border-left: 4px solid #2196f3;
            padding: 20px;
        }
        
        .info-box.soil-info {
            background: linear-gradient(135deg, #f4e4c1 0%, #e8d4a1 100%);
            border-left-color: #8B4513;
        }
        
        .professional-theme .info-box.soil-info {
            background: #faf0e6;
            border-left-color: #8B4513;
        }
        
        .info-box h3 {
            color: #1565c0;
            margin-bottom: 12px;
            font-size: 1.3em;
        }
        
        .info-box.soil-info h3 {
            color: #6B4423;
        }
        
        .professional-theme .info-box h3 {
            font-size: 1.2em;
            font-weight: 600;
        }
        
        .info-box p {
            color: #0d47a1;
            line-height: 1.6;
        }
        
        .info-box.soil-info p {
            color: #5D4E37;
        }
        
        .professional-theme .info-box p {
            color: #333;
        }
        
        .warning-box {
            background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
            padding: 20px;
            border-radius: 10px;
            border-left: 5px solid #ff9800;
            margin: 20px 0;
        }
        
        .professional-theme .warning-box {
            background: #fff9e6;
            border-radius: 4px;
            border-left: 4px solid #ff9800;
        }
        
        .warning-box h4 {
            color: #e65100;
            margin-bottom: 10px;
        }
        
        .professional-theme .warning-box h4 {
            font-weight: 600;
        }
        
        .warning-box p {
            color: #bf360c;
            line-height: 1.5;
        }
        
        .professional-theme .warning-box p {
            color: #666;
        }
        
        .error-box {
            background: linear-gradient(135deg, #ffebee 0%, #ffcdd2 100%);
            padding: 20px;
            border-radius: 10px;
            border-left: 5px solid #f44336;
            margin: 20px 0;
            display: none;
        }
        
        .professional-theme .error-box {
            background: #ffebee;
            border-radius: 4px;
            border-left: 4px solid #f44336;
        }
        
        .error-box.show {
            display: block;
            animation: shake 0.5s ease;
        }
        
        .professional-theme .error-box.show {
            animation: none;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }
        
        .export-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }
        
        .export-button {
            padding: 10px 20px;
            background: var(--dark-gradient);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .professional-theme .export-button {
            background: #34495e;
            border-radius: 4px;
        }
        
        .export-button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        .professional-theme .export-button:hover {
            transform: none;
            background: #2c3e50;
            box-shadow: none;
        }
        
        /* New styles for heatmap tabs */
        .heatmap-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            background: #f5f5f5;
            padding: 5px;
            border-radius: 10px;
        }
        
        .heatmap-tab {
            padding: 10px 20px;
            background: transparent;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            color: #666;
            transition: all 0.3s ease;
        }
        
        .heatmap-tab.active {
            background: white;
            color: #667eea;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .heatmap-tab:hover:not(.active) {
            background: rgba(255, 255, 255, 0.5);
        }
        
        /* Map container styles */
        .map-container {
            background: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.08);
            min-height: 600px;
        }
        
        .professional-theme .map-container {
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.8em;
            }
            
            .nav-tabs {
                flex-direction: column;
            }
            
            .nav-tab {
                width: 100%;
                text-align: center;
            }
            
            .content {
                padding: 20px;
            }
            
            .control-group {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .control-group label {
                min-width: auto;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body class="professional-theme">
    
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
    </div>
    
    <div class="container">
        <div class="header">
            <h1>Massachusetts Building Analysis Dashboard</h1>
            <p>Interactive Visualization of Building Inventory Data with Soil Analysis</p>
            <div class="dataset-badge">NSI-Enhanced USA Structures Dataset</div>
        </div>
        
        <div class="nav-container">
            <div class="nav-tabs">
                <button class="nav-tab active" onclick="showSection('overview')">Overview</button>
                <button class="nav-tab" onclick="showSection('clustering')">Clustering</button>
                <button class="nav-tab" onclick="showSection('temporal')">Temporal</button>
                <button class="nav-tab" onclick="showSection('pre1940')">Pre-1940</button>
                <button class="nav-tab" onclick="showSection('post1940')">Post-1940</button>
                <button class="nav-tab" onclick="showSection('occupancy')">Occupancy Clustering</button>
                <button class="nav-tab" onclick="showSection('materials')">Materials</button>
                <button class="nav-tab soil-tab" onclick="showSection('soilAnalysis')">Soil Analysis</button>
                <button class="nav-tab" onclick="showSection('interactive')">Explorer</button>
            </div>
        </div>
        
        <div class="content">
            <!-- OVERVIEW SECTION -->
            <div id="overview" class="section active">
                <div class="section-header">
                    <h2>Dashboard Overview</h2>
                    <p>Comprehensive analysis of Massachusetts building inventory from NSI-Enhanced USA Structures Dataset</p>
                </div>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="totalBuildings">Loading...</div>
                        <div class="stat-label">Total Buildings</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="avgYear">Loading...</div>
                        <div class="stat-label">Average Year Built</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="avgArea">Loading...</div>
                        <div class="stat-label">Avg Area (sqm)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="numClusters">Loading...</div>
                        <div class="stat-label">Identified Clusters</div>
                    </div>
                </div>
                
                <div class="info-box">
                    <h3>About This Dashboard</h3>
                    <p>This interactive dashboard analyzes building data from the NSI-Enhanced USA Structures Dataset for Massachusetts. 
                    The analysis includes clustering patterns, temporal distributions, material characteristics, and soil properties of buildings across different time periods.
                    All visualizations use color-blind friendly palettes and are fully interactive.</p>
                </div>
                
                <div class="chart-container">
                    <div id="overviewChart"></div>
                </div>
                
                <div class="chart-container">
                    <div id="overviewTimelineChart"></div>
                </div>
                
                <div class="export-buttons">
                    <button class="export-button" onclick="exportChart('overviewChart', 'overview')">Export Chart</button>
                    <button class="export-button" onclick="exportAllData()">Export All Data</button>
                </div>
            </div>
            
            <!-- SOIL ANALYSIS SECTION -->
            <div id="soilAnalysis" class="section">
                <div class="section-header">
                    <h2>Soil Properties and Risk Analysis</h2>
                    <p>Comprehensive analysis of soil conditions and their impact on building infrastructure</p>
                </div>
                
                <div class="stats-grid">
                    <div class="stat-card soil-card">
                        <div class="stat-value" id="highRiskBuildings">Loading...</div>
                        <div class="stat-label">High Risk Buildings</div>
                    </div>
                    <div class="stat-card soil-card">
                        <div class="stat-value" id="avgWaterTable">Loading...</div>
                        <div class="stat-label">Avg Water Table (cm)</div>
                    </div>
                    <div class="stat-card soil-card">
                        <div class="stat-value" id="poorDrainageCount">Loading...</div>
                        <div class="stat-label">Poor Drainage Sites</div>
                    </div>
                    <div class="stat-card soil-card">
                        <div class="stat-value" id="floodRiskCount">Loading...</div>
                        <div class="stat-label">Flood Risk Buildings</div>
                    </div>
                </div>
                
                <div class="info-box soil-info">
                    <h3>Soil Data Categories</h3>
                    <p><strong>Drainage Classes:</strong> Well drained, Moderately well drained, Somewhat excessively drained, Poorly drained, Very poorly drained, Excessively drained<br>
                    <strong>Flooding Frequency:</strong> None, Very rare, Rare, Occasional, Frequent<br>
                    <strong>Engineering Properties:</strong> <= 0.17 Favorable,	> 0.17 and <= 0.24 Fair, > 0.24 and <= 0.32	Poor,  > 0.32 Very poor<br>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label>Analysis Type:</label>
                        <select id="soilAnalysisType" onchange="updateSoilAnalysis()">
                            <option value="drainage">Drainage Class</option>
                            <option value="flooding">Flooding Frequency</option>
                            <option value="engineering">Engineering Properties</option>
                        </select>
                        
                        <label>Building Type Filter:</label>
                        <select id="soilBuildingType" onchange="updateSoilAnalysis()">
                            <option value="all">All Buildings</option>
                            <option value="residential">Residential Only</option>
                            <option value="commercial">Commercial Only</option>
                            <option value="industrial">Industrial Only</option>
                        </select>
                        
                        <div class="toggle-switch">
                            <label>Show Risk Overlay:</label>
                            <input type="checkbox" id="showRiskOverlay" onchange="updateSoilMap()">
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <div id="soilDistributionChart"></div>
                </div>
                
                <div class="chart-container">
                    <div id="soilByOccupancyChart"></div>
                </div>
                
                <div class="map-container">
                    <div id="soilMap"></div>
                </div>
                
                <div class="chart-container">
                    <div id="soilRiskMatrix"></div>
                </div>
                
                <div class="chart-container">
                    <div id="waterTableHistogram"></div>
                </div>
                
                <div class="warning-box">
                    <h4>Risk Assessment Methodology</h4>
                    <p>High-risk buildings are identified based on poor drainage conditions (Poorly drained or Very poorly drained) 
                    and/or frequent flooding risk (Occasional or Frequent). These conditions can impact foundation stability, 
                    basement flooding potential, and overall structural integrity over time. Buildings in high-risk zones may 
                    require additional maintenance and waterproofing measures.</p>
                </div>
            </div>
<!-- CLUSTERING SECTION -->
            <div id="clustering" class="section">
                <div class="section-header">
                    <h2>Clustering Analysis</h2>
                    <p>K-means clustering results based on building area, year built, and occupancy class (using a random sample for visualization)</p>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label>Number of Clusters:</label>
                        <select id="clusterCount">
                            <option value="5">5 Clusters</option>
                            <option value="6">6 Clusters</option>
                            <option value="7" selected>7 Clusters</option>
                            <option value="8">8 Clusters</option>
                            <option value="9">9 Clusters</option>
                        </select>
                        <button class="control-button" onclick="updateClusteringWithNewK()">Update Analysis</button>
                    </div>
                </div>
                
                <div class="chart-container">
                    <div id="clusterScatter"></div>
                </div>
                
                <div class="chart-container">
                    <div id="clusterElbow"></div>
                </div>
                
                <div class="chart-container">
                    <div id="clusterTable"></div>
                </div>
                
                <div class="chart-container">
                    <div class="control-group">
                        <label>Treemap Size By:</label>
                        <select id="treemapSizeBy" onchange="updateClusterTreemap()">
                            <option value="count">Building Count</option>
                            <option value="area">Total Floor Area</option>
                        </select>
                    </div>
                    <div id="clusterTreemap"></div>
                </div>
            </div>
<!-- TEMPORAL SECTION -->
            <div id="temporal" class="section">
                <div class="section-header">
                    <h2>Temporal Distribution</h2>
                    <p>Building construction patterns over time with multiple visualization options</p>
                </div>
                
                <div class="warning-box">
                    <h4>Data Quality Note</h4>
                    <p>Some years may have missing or incomplete data (2006, 2009, 2010, 2011, 2013, 2014, 2015, 2016). Years with notably low counts may indicate data collection gaps rather than actual construction patterns. We are currently working on addressing and correcting these gaps. </p>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label>Chart Type:</label>
                        <select id="chartType" onchange="updateTemporalChart()">
                            <option value="stacked">Stacked Area</option>
                            <option value="line">Line Plot</option>
                            <option value="normalized">Normalized (100%)</option>
                            <option value="cumulative">Cumulative</option>
                        </select>
                        
                        <label>Building Type:</label>
                        <select id="buildingType" onchange="updateTemporalChart()">
                            <option value="all">All Buildings</option>
                            <option value="residential">Residential Only</option>
                            <option value="non-residential">Non-Residential Only</option>
                        </select>
                    </div>
                </div>
                
                <div class="chart-container">
                    <div id="temporalChart"></div>
                </div>
                
                <div class="chart-container">
                    <div id="temporalAreaChart"></div>
                </div>
                
                <div class="chart-container">
                    <div id="temporalTrendChart"></div>
                </div>
            </div>
            
            <!-- PRE-1940 SECTION -->
            <div id="pre1940" class="section">
                <div class="section-header">
                    <h2>Pre-1940 Building Analysis</h2>
                    <p>Detailed analysis of historic buildings constructed before 1940</p>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label>Building Type Filter:</label>
                        <select id="pre1940Filter" onchange="updatePre1940Charts()">
                            <option value="all">All Buildings</option>
                            <option value="residential">Residential Only</option>
                            <option value="non-residential">Non-Residential Only</option>
                        </select>
                        
                        <div class="toggle-switch">
                            <label></label>
                            <input type="checkbox" id="pre1940Normalize" onchange="updatePre1940Charts()">
                        </div>
                    </div>
                </div>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="pre1940Count">Loading...</div>
                        <div class="stat-label">Pre-1940 Buildings</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="pre1940Percent">Loading...</div>
                        <div class="stat-label">Percentage of Total</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="pre1940Residential">Loading...</div>
                        <div class="stat-label">Residential Buildings</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="pre1940NonRes">Loading...</div>
                        <div class="stat-label">Non-Residential</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <div id="pre1940PieChart"></div>
                </div>
                
                <div class="chart-container">
                    <div id="pre1940BarChart"></div>
                </div>
                
                <div class="chart-container">
                    <div id="pre1940ComparisonChart"></div>
                </div>
                
                <div class="chart-container">
                    <div id="pre1940AreaChart"></div>
                </div>
            </div>
            
            <!-- POST-1940 SECTION -->
            <div id="post1940" class="section">
                <div class="section-header">
                    <h2>Post-1940 Building Analysis</h2>
                    <p>Modern building construction patterns from 1940 to present (annual data)</p>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label>Building Type:</label>
                        <select id="post1940BuildingType" onchange="updatePost1940()">
                            <option value="all">All Buildings</option>
                            <option value="residential">Residential Only</option>
                            <option value="non-residential">Non-Residential Only</option>
                        </select>
                        
                        <div class="toggle-switch">
                            <label>Normalize (100% Stack):</label>
                            <input type="checkbox" id="post1940Normalize" onchange="updatePost1940()">
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <div id="post1940Chart"></div>
                </div>
                
                <div class="chart-container">
                    <div id="post1940AreaChart"></div>
                </div>
                
                <div class="chart-container">
                    <div id="decadeComparisonChart"></div>
                </div>
            </div>

            <!-- ENHANCED OCCUPANCY CLUSTERING SECTION -->
            <div id="occupancy" class="section">
                <div class="section-header">
                    <h2>Multi-Dimensional Occupancy Clustering Analysis</h2>
                    <p>Advanced clustering analysis with dynamic feature selection for true multi-dimensional clustering</p>
                </div>
                
                <div class="info-box" style="background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%); border-left-color: #ff9800;">
                    <h3 style="color: #e65100;">Dynamic Clustering Features</h3>
                    <p style="color: #bf360c;">
                        <strong>Base Dimensions (3D):</strong> Year Built, Est GFA sqmeters, Occupancy Class<br>
                        <strong>+ Material Type (4D):</strong> Adds material type as a clustering dimension<br>
                        <strong>+ Foundation Type (4D):</strong> Adds foundation type as a clustering dimension<br>
                        <strong>+ Both (5D):</strong> Includes all dimensions for comprehensive clustering<br>
                        <strong>Real-time Reclustering:</strong> Each toggle change triggers new clustering calculations based on selected features
                    </p>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label>Select Occupancy Class:</label>
                        <select id="occupancyClass" onchange="updateOccupancyClustering()">
                            <option value="all">All Classes</option>
                            <option value="Residential">Residential</option>
                            <option value="Commercial">Commercial</option>
                            <option value="Industrial">Industrial</option>
                            <option value="Agriculture">Agriculture</option>
                            <option value="Government">Government</option>
                            <option value="Assembly">Assembly</option>
                            <option value="Education">Education</option>
                            <option value="Utility and Misc">Utility & Misc</option>
                            <option value="Unclassified">Unclassified</option>
                        </select>
                        
                        <label>Number of Clusters (K):</label>
                        <select id="occupancyK" onchange="updateOccupancyClustering()">
                            <option value="2">K = 2</option>
                            <option value="3">K = 3</option>
                            <option value="4">K = 4</option>
                            <option value="5" selected>K = 5</option>
                            <option value="6">K = 6</option>
                            <option value="7">K = 7</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <div class="toggle-switch" style="border: 2px solid #4facfe; padding: 10px; border-radius: 8px; background: rgba(79, 172, 254, 0.05);">
                            <label style="font-weight: bold; color: #0066cc;">Include Material Type:</label>
                            <input type="checkbox" id="includeMaterial" onchange="updateOccupancyClustering()">
                            <select id="materialTypeFilter" style="margin-left: 10px; display: none;" onchange="updateOccupancyClustering()">
                                <option value="all">All Materials</option>
                                <option value="W">Wood</option>
                                <option value="M">Masonry</option>
                                <option value="C">Concrete</option>
                                <option value="S">Steel</option>
                                <option value="H">Manufactured</option>
                            </select>
                        </div>
                        
                        <div class="toggle-switch" style="border: 2px solid #00f2fe; padding: 10px; border-radius: 8px; background: rgba(0, 242, 254, 0.05);">
                            <label style="font-weight: bold; color: #0099cc;">Include Foundation Type:</label>
                            <input type="checkbox" id="includeFoundation" onchange="updateOccupancyClustering()">
                            <select id="foundationTypeFilter" style="margin-left: 10px; display: none;" onchange="updateOccupancyClustering()">
                                <option value="all">All Foundations</option>
                                <option value="S">Slab</option>
                                <option value="B">Basement</option>
                                <option value="C">Crawl Space</option>
                                <option value="P">Pier</option>
                                <option value="I">Pile</option>
                                <option value="F">Fill</option>
                                <option value="W">Solid Wall</option>
                            </select>
                        </div>
                        
                        <label>Sample Type:</label>
                        <select id="sampleType" onchange="updateOccupancyClustering()" style="border: 2px solid #bd3786; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);">
                            <option value="balanced" selected>Balanced Sample (Equal Representation)</option>
                            <option value="random">Random Sample (True Distribution)</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label>Sample Size for Visualization:</label>
                        <select id="sampleSize" onchange="updateOccupancyClustering()">
                            <option value="1000">1,000 buildings</option>
                            <option value="5000" selected>5,000 buildings</option>
                            <option value="10000">10,000 buildings</option>
                            <option value="20000">20,000 buildings</option>
                        </select>
                        
                        <div class="toggle-switch">
                            <label>Log Scale (Area):</label>
                            <input type="checkbox" id="logScale" onchange="updateOccupancyClustering()">
                        </div>
                    </div>
                    
                    <div style="margin-top: 15px; padding: 12px; background: linear-gradient(135deg, #f0f4ff 0%, #e8f0ff 100%); border-radius: 8px; border-left: 4px solid #667eea;">
                        <div id="sampleTypeIndicator" style="font-size: 14px; color: #495057;">
                            <strong>Current View:</strong> <span id="currentSampleType" style="color: #7201a8; font-weight: bold;">Balanced Sample</span> - 
                            <span id="sampleDescription" style="color: #666;">Shows equal representation of all occupancy classes for better pattern visibility</span>
                        </div>
                        <div id="clusteringDimensions" style="margin-top: 8px; font-size: 14px; color: #495057;">
                            <strong>Active Clustering Dimensions:</strong> <span id="activeDimensions" style="color: #667eea; font-weight: bold;">Year, Area, Occupancy (3D)</span>
                        </div>
                        <div id="clusteringStatus" style="margin-top: 8px; font-size: 14px; color: #495057;">
                            <strong>Clustering Status:</strong> <span id="clusteringStatusText" style="color: #4facfe; font-weight: bold;">Using pre-computed base clustering</span>
                        </div>
                        <div id="filterStatus" style="margin-top: 8px; font-size: 14px; color: #495057; display: none;">
                            <strong>Active Filters:</strong> <span id="activeFilters" style="color: #4facfe; font-weight: bold;"></span>
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <div id="occupancyClusterChart"></div>
                </div>
                
                <div class="chart-container">
                    <div id="occupancyFullStatsChart"></div>
                </div>
                
                <div class="chart-container">
                    <div id="occupancySampleStatsChart"></div>
                </div>
                
                <div class="chart-container">
                    <div id="occupancyElbowChart"></div>
                </div>
            </div>
<!-- MATERIALS SECTION -->
            <div id="materials" class="section">
                <div class="section-header">
                    <h2>Building Materials & Foundation Analysis</h2>
                    <p>Correlation between material types and foundation types - Click on any cell to see occupancy breakdown</p>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label>Data Filter:</label>
                        <select id="materialFilter" onchange="updateMaterialsHeatmap()">
                            <option value="all">All Buildings</option>
                            <option value="pre1940">Pre-1940 Only</option>
                            <option value="post1940">Post-1940 Only</option>
                        </select>
                        
                        <div class="toggle-switch">
                            <label>Log Scale (Heatmap Only):</label>
                            <input type="checkbox" id="heatmapLogScale" onchange="updateHeatmapOnly()">
                        </div>
                        
                        <label style="margin-left: 20px;">Breakdown Chart Type:</label>
                        <select id="breakdownChartType" onchange="updateOccupancyBreakdown()">
                            <option value="pie">Pie Chart</option>
                            <option value="bar">Bar Chart</option>
                            <option value="horizontal-bar">Horizontal Bar</option>
                        </select>
                    </div>
                </div>
                
                <div class="info-box">
                    <h3>Material & Foundation Type Codes</h3>
                    <p><strong>Material Types:</strong> M = Masonry, W = Wood, H = Manufactured, S = Steel, C = Concrete<br>
                    <strong>Foundation Types:</strong> C = Crawl Space, B = Basement, S = Slab, P = Pier, I = Pile, F = Fill, W = Solid Wall<br>
                    <strong style="color: #667eea;">👉 Click on any cell in either heatmap to see the occupancy class distribution for that combination</strong></p>
                </div>
                
                <!-- Heatmap tabs for switching between count and area -->
                <div class="heatmap-tabs">
                    <button class="heatmap-tab active" id="countHeatmapTab" onclick="showHeatmap('count')">Building Count</button>
                    <button class="heatmap-tab" id="areaHeatmapTab" onclick="showHeatmap('area')">Total Est GFA (sqm)</button>
                </div>
                
                <div class="chart-container" id="countHeatmapContainer">
                    <div id="materialsHeatmap"></div>
                </div>
                
                <div class="chart-container" id="areaHeatmapContainer" style="display: none;">
                    <div id="materialsAreaHeatmap"></div>
                </div>
                
                <div class="chart-container" id="occupancyBreakdownContainer" style="display: none;">
                    <div class="section-header" style="margin-top: 0; padding-top: 20px;">
                        <h3 id="breakdownTitle">Occupancy Class Distribution</h3>
                        <p id="breakdownSubtitle">Click on a heatmap cell to see the breakdown</p>
                    </div>
                    <div id="occupancyBreakdownChart"></div>
                </div>
                
                <div class="chart-container">
                    <div id="materialsTrendChart"></div>
                </div>
            </div>
            
            <!-- INTERACTIVE EXPLORER SECTION -->
            <div id="interactive" class="section">
                <div class="section-header">
                    <h2>Interactive Data Explorer</h2>
                    <p>Explore the data with custom filters and advanced visualizations (using a random sample)</p>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label>Year Range:</label>
                        <input type="number" id="yearStart" value="1900" min="1900" max="2024" style="width: 100px">
                        <span>to</span>
                        <input type="number" id="yearEnd" value="2024" min="1900" max="2024" style="width: 100px">
                    </div>
                    <div class="control-group">
                        <label>Est GFA Range (sqm):</label>
                        <input type="number" id="areaMin" value="0" min="0" style="width: 100px">
                        <span>to</span>
                        <input type="number" id="areaMax" value="10000" min="0" style="width: 100px">
                    </div>
                    <div class="control-group">
                        <label>Visualization:</label>
                        <select id="vizType">
                            <option value="box">Box Plot</option>
                            <option value="scatter3d">3D Scatter Plot</option>
                            <option value="sunburst">Sunburst Chart</option>
                            <option value="parallel">Parallel Coordinates</option>
                            <option value="violin">Violin Plot</option>
                            <option value="treemap">Treemap</option>
                        </select>
                        <button class="control-button" onclick="updateInteractiveExplorer()">Update Visualization</button>
                    </div>
                </div>
                
                <div class="chart-container">
                    <div id="interactiveChart"></div>
                </div>
                
                <div class="info-box">
                    <h3>Tips for Interactive Explorer</h3>
                    <p>• 3D Scatter: Rotate with mouse, zoom with scroll wheel<br>
                       • Sunburst: Click segments to zoom in, click center to zoom out<br>
                       • Parallel Coordinates: Drag axes to reorder, brush to filter<br>
                       • All charts: Hover for details, double-click to reset view</p>
                </div>
            </div>
        </div>
        
        <div class="error-box" id="errorBox">
            <h3>Error Loading Data</h3>
            <p id="errorMessage">Unable to load building data. Please ensure building_data.json is in the same directory.</p>
        </div>
    </div>
    
    <script>
        // Global variables for data
        let buildingData = null;
        let isDataLoaded = false;
        let currentClusterK = 7;
        
        // Global variables for material selection
        let currentMaterialSelection = null;
        let currentOccupancyData = null;
        let currentHeatmapType = 'count';
        
        // Global variables for soil analysis
        let soilAnalysisData = null;
        let soilMapData = null;
        
        // Plasma colorscale
        const plasmaColorscale = 'Plasma';
        const plasmaColors = [
            '#0d0887', '#46039f', '#7201a8', '#9c179e', '#bd3786',
            '#d8576b', '#ed7953', '#fb9f3a', '#fdca26', '#f0f921'
        ];
        
        // Soil-specific colors
        const soilColors = {
            drainage: {
                'Well drained': '#2E7D32',
                'Moderately well drained': '#66BB6A',
                'Somewhat excessively drained': '#FDD835',
                'Poorly drained': '#FF9800',
                'Very poorly drained': '#E53935',
                'Excessively drained': '#1565C0'
            },
            flooding: {
                'Low': '#FDD835', 
                'Moderate': '#FF9800', 
                'High': '#E53935'
            },
            engineering: {
                'Favorable': '#2E7D32',
                'Fair': '#FDD835',
                'Poor': '#FF9800',
                'Very poor': '#E53935'
            }
        };
        
        // Material and Foundation type mappings
        const materialTypeMap = {
            'M': 'Masonry',
            'W': 'Wood',
            'H': 'Manufactured',
            'S': 'Steel',
            'C': 'Concrete'
        };
        
        const foundationTypeMap = {
            'C': 'Crawl Space',
            'B': 'Basement',
            'S': 'Slab',
            'P': 'Pier',
            'I': 'Pile',
            'F': 'Fill',
            'W': 'Solid Wall'
        };
        
        function getPlasmaColors(n) {
            if (n <= 10) return plasmaColors.slice(0, n);
            const colors = [];
            for (let i = 0; i < n; i++) {
                const idx = Math.floor(i * 9 / (n - 1));
                colors.push(plasmaColors[Math.min(idx, 9)]);
            }
            return colors;
        }
        
        window.addEventListener('error', function(event) {
            console.error('Error details:', event);
            return true;
        });

        const originalNewPlot = Plotly.newPlot;
        Plotly.newPlot = function(gd, data, layout, config) {
            try {
                if (Array.isArray(data)) {
                    data.forEach(trace => {
                        if (trace && trace.marker && typeof trace.marker === 'object') {
                            if (trace.marker.line === undefined) {
                                delete trace.marker.line;
                            }
                        }
                    });
                }
                return originalNewPlot.call(this, gd, data, layout, config);
            } catch (error) {
                console.error('Plotly error:', error);
                return Promise.resolve();
            }
        };

        document.addEventListener('DOMContentLoaded', function() {
            loadData();
            
            // Toggle material/foundation filter visibility
            document.getElementById('includeMaterial').addEventListener('change', function() {
                document.getElementById('materialTypeFilter').style.display = this.checked ? 'inline-block' : 'none';
                updateOccupancyClustering();
            });
            
            document.getElementById('includeFoundation').addEventListener('change', function() {
                document.getElementById('foundationTypeFilter').style.display = this.checked ? 'inline-block' : 'none';
                updateOccupancyClustering();
            });
        });
        
        async function loadData() {
            try {
                console.log('Loading main data file...');
                
                // Load main data file
                const response = await fetch('building_data.json');
                if (!response.ok) {
                    throw new Error('Failed to load main data file');
                }
                
                buildingData = await response.json();
                
                // Store soil analysis data globally
                if (buildingData.soil_analysis) {
                    soilAnalysisData = buildingData.soil_analysis;
                    console.log('Soil analysis data loaded');
                }
                
                // Check version and format
                const version = buildingData.metadata?.version;
                const hasSplitSamples = buildingData.metadata?.samples_split;
                
                if (hasSplitSamples && buildingData.metadata?.samples_files) {
                    console.log('Detected multi-file sample format, loading sample chunks...');
                    
                    // Initialize empty arrays for samples
                    buildingData.building_samples_random = [];
                    buildingData.building_samples_balanced = [];
                    
                    const sampleFiles = buildingData.metadata.samples_files;
                    console.log(`Loading ${sampleFiles.length} sample files...`);
                    
                    // Load all sample files
                    let loadedFiles = 0;
                    let failedFiles = 0;
                    
                    for (const fileInfo of sampleFiles) {
                        try {
                            const sampleResponse = await fetch(fileInfo.filename);
                            if (sampleResponse.ok) {
                                const sampleData = await sampleResponse.json();
                                
                                // Add samples to appropriate array
                                if (fileInfo.type === 'random') {
                                    buildingData.building_samples_random.push(...sampleData.samples);
                                } else if (fileInfo.type === 'balanced') {
                                    buildingData.building_samples_balanced.push(...sampleData.samples);
                                }
                                
                                loadedFiles++;
                                console.log(`  Loaded ${fileInfo.filename} (${fileInfo.sample_count} samples)`);
                            } else {
                                console.warn(`  Failed to load ${fileInfo.filename}`);
                                failedFiles++;
                            }
                        } catch (error) {
                            console.error(`  Error loading ${fileInfo.filename}:`, error);
                            failedFiles++;
                        }
                    }
                    
                    console.log(`Sample loading complete: ${loadedFiles}/${sampleFiles.length} files loaded`);
                    console.log(`  Random samples: ${buildingData.building_samples_random.length}`);
                    console.log(`  Balanced samples: ${buildingData.building_samples_balanced.length}`);
                    
                    // If too many files failed, create fallback samples
                    if (failedFiles > sampleFiles.length / 2) {
                        console.warn('Too many sample files failed to load, creating minimal fallback samples');
                        createFallbackSamples();
                    }
                    
                } else if (buildingData.metadata?.has_samples_file) {
                    // Version 2.0 - single samples file
                    console.log('Detected single sample file format, loading samples...');
                    
                    try {
                        const samplesResponse = await fetch('building_data_samples.json');
                        if (samplesResponse.ok) {
                            const samplesData = await samplesResponse.json();
                            buildingData.building_samples_random = samplesData.building_samples_random;
                            buildingData.building_samples_balanced = samplesData.building_samples_balanced;
                            console.log('Samples loaded successfully');
                        } else {
                            console.warn('Samples file not found, creating fallback samples');
                            createFallbackSamples();
                        }
                    } catch (error) {
                        console.error('Error loading samples:', error);
                        createFallbackSamples();
                    }
                    
                } else {
                    // Version 1.0 - samples in main file
                    console.log('Using legacy single-file format');
                    
                    if (!buildingData.building_samples_random || !buildingData.building_samples_balanced) {
                        console.warn('No samples found, creating fallback samples');
                        createFallbackSamples();
                    }
                }
                
                // Process temporal data
                if (buildingData.temporal_data) {
                    buildingData.temporal_data = buildingData.temporal_data.map(d => {
                        if (d.year === 1939) {
                            d.display_year = 'pre-1940';
                        }
                        return d;
                    });
                }
                
                isDataLoaded = true;
                document.getElementById('loadingOverlay').classList.add('hidden');
                
                console.log('Data loading complete');
                console.log(`Total buildings: ${buildingData.metadata.total_buildings}`);
                console.log(`Random samples available: ${buildingData.building_samples_random?.length || 0}`);
                console.log(`Balanced samples available: ${buildingData.building_samples_balanced?.length || 0}`);
                console.log(`Soil analysis available: ${soilAnalysisData ? 'Yes' : 'No'}`);
                
                initializeDashboard();
                
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('loadingOverlay').classList.add('hidden');
                document.getElementById('errorBox').classList.add('show');
                document.getElementById('errorMessage').textContent = error.message;
                
                // Load sample data as fallback
                console.log('Loading complete sample data as fallback...');
                loadSampleData();
            }
        }

        function createFallbackSamples() {
            console.log('Creating fallback samples...');
            
            const occupancyClasses = buildingData.summary_stats?.occupancy_classes || 
                                ['Residential', 'Commercial', 'Industrial', 'Agriculture', 
                                    'Government', 'Assembly', 'Education', 'Utility and Misc', 'Unclassified'];
            const materials = ['W', 'M', 'C', 'S', 'H'];
            const foundations = ['S', 'B', 'C', 'P', 'F', 'I', 'W'];
            const drainageClasses = ['Well drained', 'Moderately well drained', 'Somewhat excessively drained', 
                                    'Poorly drained', 'Very poorly drained', 'Excessively drained'];
            const floodFreqs = ['None', 'Very rare', 'Rare', 'Occasional', 'Frequent'];
            const engProps = ['Favorable', 'Fair', 'Poor', 'Very poor'];
            
            // Create minimal samples for visualization
            const randomSamples = [];
            const balancedSamples = [];
            
            // Random samples - 2000 total (reduced for fallback)
            for (let i = 0; i < 2000; i++) {
                const sample = {
                    year_built: Math.floor(Math.random() * 124) + 1900,
                    'Est GFA sqmeters': Math.random() * 1000 + 50,
                    OCC_CLS: occupancyClasses[Math.floor(Math.random() * occupancyClasses.length)],
                    material_type: materials[Math.floor(Math.random() * materials.length)],
                    foundation_type: foundations[Math.floor(Math.random() * foundations.length)],
                    cluster: Math.floor(Math.random() * 7),
                    // Add soil properties
                    drainagecl: drainageClasses[Math.floor(Math.random() * drainageClasses.length)],
                    flodfreqcl: floodFreqs[Math.floor(Math.random() * floodFreqs.length)],
                    eng_property: engProps[Math.floor(Math.random() * engProps.length)],
                    wtdepannmin: Math.random() * 300,
                    LONGITUDE: -71 - Math.random() * 2,
                    LATITUDE: 41 + Math.random() * 2
                };
                
                // Add pre-computed clusters
                for (let k = 2; k <= 9; k++) {
                    sample[`cluster_base_k${k}`] = Math.floor(Math.random() * k);
                    sample[`cluster_material_k${k}`] = Math.floor(Math.random() * k);
                    sample[`cluster_foundation_k${k}`] = Math.floor(Math.random() * k);
                    sample[`cluster_both_k${k}`] = Math.floor(Math.random() * k);
                    sample[`cluster_k${k}`] = sample[`cluster_base_k${k}`];
                }
                
                randomSamples.push(sample);
            }
            
            // Balanced samples - 200 per class
            for (let occ of occupancyClasses) {
                for (let i = 0; i < 200; i++) {
                    const sample = {
                        year_built: Math.floor(Math.random() * 124) + 1900,
                        'Est GFA sqmeters': Math.random() * 1000 + 50,
                        OCC_CLS: occ,
                        material_type: materials[Math.floor(Math.random() * materials.length)],
                        foundation_type: foundations[Math.floor(Math.random() * foundations.length)],
                        cluster: Math.floor(Math.random() * 7),
                        // Add soil properties
                        drainagecl: drainageClasses[Math.floor(Math.random() * drainageClasses.length)],
                        flodfreqcl: floodFreqs[Math.floor(Math.random() * floodFreqs.length)],
                        eng_property: engProps[Math.floor(Math.random() * engProps.length)],
                        wtdepannmin: Math.random() * 300,
                        LONGITUDE: -71 - Math.random() * 2,
                        LATITUDE: 41 + Math.random() * 2
                    };
                    
                    // Add pre-computed clusters
                    for (let k = 2; k <= 9; k++) {
                        sample[`cluster_base_k${k}`] = Math.floor(Math.random() * k);
                        sample[`cluster_material_k${k}`] = Math.floor(Math.random() * k);
                        sample[`cluster_foundation_k${k}`] = Math.floor(Math.random() * k);
                        sample[`cluster_both_k${k}`] = Math.floor(Math.random() * k);
                        sample[`cluster_k${k}`] = sample[`cluster_base_k${k}`];
                    }
                    
                    balancedSamples.push(sample);
                }
            }
            
            buildingData.building_samples_random = randomSamples;
            buildingData.building_samples_balanced = balancedSamples;
            
            // Create fallback soil analysis data if not present
            if (!soilAnalysisData) {
                soilAnalysisData = {
                    drainage_class_stats: {
                        counts: {
                            'Well drained': 45000,
                            'Moderately well drained': 38000,
                            'Somewhat excessively drained': 25000,
                            'Poorly drained': 18000,
                            'Very poorly drained': 8000,
                            'Excessively drained': 12000
                        },
                        percentages: {
                            'Well drained': 30.8,
                            'Moderately well drained': 26.0,
                            'Somewhat excessively drained': 17.1,
                            'Poorly drained': 12.3,
                            'Very poorly drained': 5.5,
                            'Excessively drained': 8.2
                        }
                    },
                    flooding_freq_stats: {
                        counts: {
                            'None': 85000,
                            'Very rare': 28000,
                            'Rare': 18000,
                            'Occasional': 10000,
                            'Frequent': 5000
                        },
                        percentages: {
                            'None': 58.2,
                            'Very rare': 19.2,
                            'Rare': 12.3,
                            'Occasional': 6.8,
                            'Frequent': 3.4
                        }
                    },
                    water_table_stats: {
                        mean: 125.5,
                        median: 110.0,
                        std: 75.2,
                        min: 0,
                        max: 300,
                        q25: 60,
                        q75: 180
                    },
                    engineering_property_stats: {
                        counts: {
                            'Favorable': 55000,
                            'Fair': 48000,
                            'Poor': 28000,
                            'Very poor': 15000
                        },
                        percentages: {
                            'Favorable': 37.7,
                            'Fair': 32.9,
                            'Poor': 19.2,
                            'Very poor': 10.3
                        }
                    },
                    soil_risk_analysis: {
                        high_risk_count: 28000,
                        high_risk_percentage: 19.2,
                        high_risk_by_occupancy: {
                            'Residential': 18000,
                            'Commercial': 5000,
                            'Industrial': 3000,
                            'Other': 2000
                        },
                        high_risk_avg_year: 1965,
                        high_risk_total_area: 8500000
                    },
                    spatial_distribution: randomSamples.slice(0, 1000).map(s => ({
                        lon: s.LONGITUDE,
                        lat: s.LATITUDE,
                        occupancy: s.OCC_CLS,
                        year_built: s.year_built,
                        area: s['Est GFA sqmeters'],
                        drainage: s.drainagecl,
                        flooding: s.flodfreqcl,
                        eng_property: s.eng_property,
                        water_table: s.wtdepannmin
                    }))
                };
                
                buildingData.soil_analysis = soilAnalysisData;
            }
            
            console.log(`Created ${randomSamples.length} fallback random samples`);
            console.log(`Created ${balancedSamples.length} fallback balanced samples`);
        }
        
        function loadSampleData() {
            console.log('Loading sample data as fallback...');
            buildingData = generateSampleData();
            soilAnalysisData = buildingData.soil_analysis;
            isDataLoaded = true;
            initializeDashboard();
        }
        
        function generateSampleData() {
            // Generate complete sample data including soil analysis
            const occupancyClasses = ['Residential', 'Commercial', 'Industrial', 'Agriculture', 
                                     'Government', 'Assembly', 'Education', 'Utility and Misc', 'Unclassified'];
            const materials = ['W', 'M', 'C', 'S', 'H'];
            const foundations = ['S', 'B', 'C', 'P', 'F'];
            
            const temporalData = [];
            for (let year = 1900; year <= 2024; year++) {
                for (let occ of occupancyClasses) {
                    let count = Math.floor(Math.random() * 1000 * Math.exp(-(2000-year)/50));
                    if (year < 1940) count *= 0.3;
                    temporalData.push({
                        year: year,
                        display_year: year < 1940 ? 'pre-1940' : year.toString(),
                        occupancy: occ,
                        count: count,
                        avg_area: Math.random() * 500 + 50,
                        total_area: count * (Math.random() * 500 + 50)
                    });
                }
            }
            
            // Generate enhanced samples with multi-dimensional clustering and soil data
            const buildingSamples = [];
            for (let i = 0; i < 20000; i++) {
                const sample = {
                    year_built: Math.floor(Math.random() * 124) + 1900,
                    'Est GFA sqmeters': Math.random() * 1000 + 50,
                    OCC_CLS: occupancyClasses[Math.floor(Math.random() * occupancyClasses.length)],
                    cluster: Math.floor(Math.random() * 7),
                    material_type: materials[Math.floor(Math.random() * materials.length)],
                    foundation_type: foundations[Math.floor(Math.random() * foundations.length)],
                    drainagecl: ['Well drained', 'Moderately well drained', 'Poorly drained'][Math.floor(Math.random() * 3)],
                    flodfreqcl: ['None', 'Rare', 'Occasional'][Math.floor(Math.random() * 3)],
                    eng_property: ['Favorable', 'Fair', 'Poor'][Math.floor(Math.random() * 3)],
                    wtdepannmin: Math.random() * 300,
                    LONGITUDE: -71 - Math.random() * 2,
                    LATITUDE: 41 + Math.random() * 2
                };
                
                // Add pre-computed clusters for different feature combinations
                for (let k = 2; k <= 9; k++) {
                    sample[`cluster_base_k${k}`] = Math.floor(Math.random() * k);
                    sample[`cluster_material_k${k}`] = Math.floor(Math.random() * k);
                    sample[`cluster_foundation_k${k}`] = Math.floor(Math.random() * k);
                    sample[`cluster_both_k${k}`] = Math.floor(Math.random() * k);
                }
                
                buildingSamples.push(sample);
            }
            
            // Generate soil analysis data
            const soilAnalysis = {
                drainage_class_stats: {
                    counts: {
                        'Well drained': 85000,
                        'Moderately well drained': 65000,
                        'Somewhat excessively drained': 45000,
                        'Poorly drained': 35000,
                        'Very poorly drained': 15000,
                        'Excessively drained': 25000
                    },
                    percentages: {
                        'Well drained': 31.5,
                        'Moderately well drained': 24.1,
                        'Somewhat excessively drained': 16.7,
                        'Poorly drained': 13.0,
                        'Very poorly drained': 5.6,
                        'Excessively drained': 9.3
                    }
                },
                flooding_freq_stats: {
                    counts: {
                        'None': 150000,
                        'Very rare': 50000,
                        'Rare': 35000,
                        'Occasional': 25000,
                        'Frequent': 10000
                    },
                    percentages: {
                        'None': 55.6,
                        'Very rare': 18.5,
                        'Rare': 13.0,
                        'Occasional': 9.3,
                        'Frequent': 3.7
                    }
                },
                water_table_stats: {
                    mean: 145.2,
                    median: 125.0,
                    std: 85.3,
                    min: 0,
                    max: 300,
                    q25: 75,
                    q75: 200
                },
                engineering_property_stats: {
                    counts: {
                        'Favorable': 100000,
                        'Fair': 85000,
                        'Poor': 55000,
                        'Very poor': 30000
                    },
                    percentages: {
                        'Favorable': 37.0,
                        'Fair': 31.5,
                        'Poor': 20.4,
                        'Very poor': 11.1
                    }
                },
                soil_by_occupancy: {},
                spatial_distribution: buildingSamples.slice(0, 5000).map(s => ({
                    lon: s.LONGITUDE,
                    lat: s.LATITUDE,
                    occupancy: s.OCC_CLS,
                    year_built: s.year_built,
                    area: s['Est GFA sqmeters'],
                    drainage: s.drainagecl,
                    flooding: s.flodfreqcl,
                    eng_property: s.eng_property,
                    water_table: s.wtdepannmin
                })),
                soil_risk_analysis: {
                    high_risk_count: 45000,
                    high_risk_percentage: 16.7,
                    high_risk_by_occupancy: {
                        'Residential': 30000,
                        'Commercial': 8000,
                        'Industrial': 5000,
                        'Other': 2000
                    },
                    high_risk_avg_year: 1972,
                    high_risk_total_area: 12500000
                }
            };
            
            // Generate enhanced occupancy clusters
            const occupancyClustersEnhanced = {};
            for (let occ of ['all', ...occupancyClasses]) {
                const featureCombos = {};
                for (let combo of ['base', 'material', 'foundation', 'both']) {
                    const kValues = {};
                    for (let k = 2; k <= 7; k++) {
                        const clusters = [];
                        for (let c = 0; c < k; c++) {
                            const cluster = {
                                cluster_id: c,
                                count: Math.floor(Math.random() * 10000) + 1000,
                                avg_area: Math.random() * 500 + 100,
                                avg_year: Math.floor(Math.random() * 50) + 1960,
                                std_area: Math.random() * 100,
                                std_year: Math.random() * 20
                            };
                            
                            if (combo === 'material' || combo === 'both') {
                                cluster.dominant_material = materials[Math.floor(Math.random() * materials.length)];
                            }
                            if (combo === 'foundation' || combo === 'both') {
                                cluster.dominant_foundation = foundations[Math.floor(Math.random() * foundations.length)];
                            }
                            
                            clusters.push(cluster);
                        }
                        
                        kValues[k] = {
                            wcss: Math.random() * 10000 + 5000,
                            clusters: clusters
                        };
                    }
                    featureCombos[combo] = kValues;
                }
                
                occupancyClustersEnhanced[occ] = {
                    total_buildings: Math.floor(Math.random() * 100000) + 10000,
                    feature_combinations: featureCombos
                };
            }
            
            const summaryStats = {
                total_buildings: 2500000,
                avg_year_built: 1978,
                avg_area_sqm: 285.5,
                min_year: 1900,
                max_year: 2024,
                occupancy_classes: occupancyClasses
            };
            
            const overviewOccupancyCounts = {
                'Residential': 2100000,
                'Commercial': 180000,
                'Industrial': 80000,
                'Agriculture': 45000,
                'Government': 35000,
                'Assembly': 25000,
                'Education': 20000,
                'Utility and Misc': 10000,
                'Unclassified': 5000
            };
            
            return {
                metadata: {
                    total_buildings: 2500000,
                    date_processed: new Date().toISOString(),
                    source_file: 'sample_data.csv',
                    version: '3.1'
                },
                summary_stats: summaryStats,
                overview_occupancy_counts: overviewOccupancyCounts,
                clustering: {
                    elbow_k_values: [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
                    elbow_wcss_values: [50000, 35000, 25000, 20000, 18000, 17000, 16500, 16000, 15800, 15600, 15400, 15300, 15200, 15100],
                    clusters: [
                        { cluster_id: 0, count: 450000, most_common_occ: 'Residential', area_mean: 250, area_median: 200, year_mean: 1985, year_median: 1982 },
                        { cluster_id: 1, count: 380000, most_common_occ: 'Commercial', area_mean: 450, area_median: 400, year_mean: 1992, year_median: 1990 },
                        { cluster_id: 2, count: 320000, most_common_occ: 'Residential', area_mean: 180, area_median: 150, year_mean: 1968, year_median: 1965 },
                        { cluster_id: 3, count: 280000, most_common_occ: 'Industrial', area_mean: 850, area_median: 750, year_mean: 1978, year_median: 1975 },
                        { cluster_id: 4, count: 220000, most_common_occ: 'Agriculture', area_mean: 320, area_median: 280, year_mean: 1955, year_median: 1952 },
                        { cluster_id: 5, count: 180000, most_common_occ: 'Government', area_mean: 550, area_median: 500, year_mean: 1988, year_median: 1986 },
                        { cluster_id: 6, count: 150000, most_common_occ: 'Education', area_mean: 680, area_median: 620, year_mean: 1975, year_median: 1973 }
                    ]
                },
                temporal_data: temporalData,
                pre1940: {
                    total_count: 450000,
                    occupancy_counts: {
                        'Residential': 320000,
                        'Commercial': 45000,
                        'Industrial': 28000,
                        'Agriculture': 22000,
                        'Government': 12000,
                        'Assembly': 8000,
                        'Education': 6000,
                        'Utility and Misc': 5000,
                        'Unclassified': 4000
                    },
                    residential_count: 320000,
                    non_residential_count: 130000,
                    percentage_of_total: 18
                },
                post1940: {
                    '1940s': { total: 180000, occupancy_counts: { 'Residential': 120000, 'Commercial': 30000, 'Industrial': 20000, 'Other': 10000 } },
                    '1950s': { total: 250000, occupancy_counts: { 'Residential': 180000, 'Commercial': 35000, 'Industrial': 25000, 'Other': 10000 } },
                    '1960s': { total: 320000, occupancy_counts: { 'Residential': 220000, 'Commercial': 50000, 'Industrial': 35000, 'Other': 15000 } },
                    '1970s': { total: 380000, occupancy_counts: { 'Residential': 260000, 'Commercial': 60000, 'Industrial': 40000, 'Other': 20000 } },
                    '1980s': { total: 340000, occupancy_counts: { 'Residential': 230000, 'Commercial': 55000, 'Industrial': 35000, 'Other': 20000 } },
                    '1990s': { total: 290000, occupancy_counts: { 'Residential': 200000, 'Commercial': 45000, 'Industrial': 30000, 'Other': 15000 } },
                    '2000s': { total: 260000, occupancy_counts: { 'Residential': 180000, 'Commercial': 40000, 'Industrial': 25000, 'Other': 15000 } },
                    '2010s': { total: 220000, occupancy_counts: { 'Residential': 150000, 'Commercial': 35000, 'Industrial': 20000, 'Other': 15000 } }
                },
                occupancy_clusters: {},
                occupancy_clusters_enhanced: occupancyClustersEnhanced,
                materials_foundation: {
                    all: {
                        matrix: [[1000, 800, 600, 400, 200],
                                [800, 1200, 500, 300, 100],
                                [600, 500, 900, 200, 150],
                                [400, 300, 200, 800, 100],
                                [200, 100, 150, 100, 500]],
                        area_matrix: [[1000000, 800000, 600000, 400000, 200000],
                                     [800000, 1200000, 500000, 300000, 100000],
                                     [600000, 500000, 900000, 200000, 150000],
                                     [400000, 300000, 200000, 800000, 100000],
                                     [200000, 100000, 150000, 100000, 500000]],
                        materials: materials,
                        foundations: foundations,
                        occupancy_breakdown: {}
                    }
                },
                soil_analysis: soilAnalysis,
                building_samples_random: buildingSamples,
                building_samples_balanced: buildingSamples
            };
        }

        function initializeDashboard() {
            if (!isDataLoaded || !buildingData) {
                console.error('Data not loaded');
                return;
            }
            
            updateStatistics();
            updateOverview();
            updateClustering();
            updateTemporalChart();
            updatePre1940Charts();
            updatePost1940();
            updateOccupancyClustering();
            updateMaterialsHeatmap();
            updateSoilAnalysis();
            updateInteractiveExplorer();
        }
        
        function updateStatistics() {
            if (!buildingData) return;
            
            const stats = buildingData.summary_stats;
            const pre1940 = buildingData.pre1940;
            
            const formatNumber = (num) => {
                if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
                if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
                return num.toString();
            };
            
            document.getElementById('totalBuildings').textContent = formatNumber(stats.total_buildings);
            document.getElementById('avgYear').textContent = Math.round(stats.avg_year_built).toString();
            document.getElementById('avgArea').textContent = Math.round(stats.avg_area_sqm) + ' m²';
            document.getElementById('numClusters').textContent = currentClusterK.toString();
            
            document.getElementById('pre1940Count').textContent = formatNumber(pre1940.total_count);
            document.getElementById('pre1940Percent').textContent = pre1940.percentage_of_total + '%';
            document.getElementById('pre1940Residential').textContent = formatNumber(pre1940.residential_count);
            document.getElementById('pre1940NonRes').textContent = formatNumber(pre1940.non_residential_count);
            
            // Update soil statistics if available
            if (soilAnalysisData) {
                document.getElementById('highRiskBuildings').textContent = formatNumber(soilAnalysisData.soil_risk_analysis?.high_risk_count || 0);
                document.getElementById('avgWaterTable').textContent = Math.round(soilAnalysisData.water_table_stats?.mean || 0).toString();
                
                // Count poor drainage sites
                const poorDrainageCount = (soilAnalysisData.drainage_class_stats?.counts?.['Poorly drained'] || 0) +
                                         (soilAnalysisData.drainage_class_stats?.counts?.['Very poorly drained'] || 0);
                document.getElementById('poorDrainageCount').textContent = formatNumber(poorDrainageCount);
                
                // Count flood risk buildings
                const floodRiskCount = (soilAnalysisData.flooding_freq_stats?.counts?.['Occasional'] || 0) +
                                      (soilAnalysisData.flooding_freq_stats?.counts?.['Frequent'] || 0);
                document.getElementById('floodRiskCount').textContent = formatNumber(floodRiskCount);
            }
        }
        
        function showSection(sectionId) {
            const sections = document.querySelectorAll('.section');
            sections.forEach(section => section.classList.remove('active'));
            
            document.getElementById(sectionId).classList.add('active');
            
            const tabs = document.querySelectorAll('.nav-tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');
            
            // Special handling for soil analysis tab
            if (sectionId === 'soilAnalysis') {
                event.target.classList.add('soil-tab');
            }
            
            window.dispatchEvent(new Event('resize'));
        }
        
        // Soil Analysis Functions
        function updateSoilAnalysis() {
            if (!soilAnalysisData) {
                console.warn('No soil analysis data available');
                return;
            }
            
            const analysisType = document.getElementById('soilAnalysisType').value;
            const buildingType = document.getElementById('soilBuildingType').value;
            
            // Update distribution chart based on analysis type
            updateSoilDistributionChart(analysisType, buildingType);
            
            // Update occupancy-based soil analysis
            updateSoilByOccupancyChart(analysisType);
            
            // Update soil map
            updateSoilMap();
            
            // Update risk matrix
            updateSoilRiskMatrix();
            
            // Update water table histogram
            updateWaterTableHistogram();
        }
        
        function updateSoilDistributionChart(analysisType, buildingType) {
            let data, title, colors;
            
            switch(analysisType) {
                case 'drainage':
                    data = soilAnalysisData.drainage_class_stats;
                    title = 'Buildings by Drainage Class';
                    colors = Object.values(soilColors.drainage);
                    break;
                case 'flooding':
                    data = soilAnalysisData.flooding_freq_stats;
                    title = 'Buildings by Flooding Frequency';
                    colors = Object.values(soilColors.flooding);
                    break;
                case 'engineering':
                    data = soilAnalysisData.engineering_property_stats;
                    title = 'Buildings by Engineering Properties';
                    colors = Object.values(soilColors.engineering);
                    break;
                case 'watertable':
                    // Create histogram for water table depth
                    updateWaterTableChart();
                    return;
                case 'risk':
                    // Show risk assessment summary
                    updateRiskAssessmentChart();
                    return;
            }
            
            if (!data || !data.counts) {
                console.warn('No data available for', analysisType);
                return;
            }
            
            const sortedData = Object.entries(data.counts).sort((a, b) => b[1] - a[1]);
            
            const barData = [{
                x: sortedData.map(([k, v]) => {
                    return k.replace(' drained', '')
                            .replace('Excessively', 'Excessive')
                            .replace('Moderately well', 'Moderate')
                            .replace('Somewhat excessively', 'Somewhat');
                }),
                y: sortedData.map(([k, v]) => v),
                type: 'bar',
                marker: {
                    color: sortedData.map(([k, v]) => {
                        if (analysisType === 'drainage') return soilColors.drainage[k] || '#888';
                        if (analysisType === 'flooding') return soilColors.flooding[k] || '#888';
                        if (analysisType === 'engineering') return soilColors.engineering[k] || '#888';
                        return colors[sortedData.findIndex(item => item[0] === k) % colors.length];
                    }),
                    line: {
                        color: 'white',
                        width: 1
                    }
                },
                text: sortedData.map(([k, v]) => `${(data.percentages[k] || 0).toFixed(1)}%`),
            }];
            
            const layout = {
                title: {
                    text: title,
                    font: { size: 20, color: '#333' }
                },
                xaxis: { 
                    title: analysisType.charAt(0).toUpperCase() + analysisType.slice(1) + ' Category',
                    tickangle: -45
                },
                yaxis: { 
                    title: 'Number of Buildings'
                },
                height: 450,
                showlegend: false
            };
            
            Plotly.newPlot('soilDistributionChart', barData, layout, {responsive: true});
        }
        
        function updateWaterTableChart() {
            const stats = soilAnalysisData.water_table_stats;
            
            if (!stats) {
                console.warn('No water table data available');
                return;
            }
            
            // Create box plot
            const boxData = [{
                y: Array(1000).fill().map(() => {
                    // Generate sample data based on statistics
                    const z = (Math.random() - 0.5) * 2;
                    return Math.max(0, Math.min(300, stats.mean + z * stats.std));
                }),
                type: 'box',
                name: 'Water Table Depth',
                marker: {
                    color: '#4169E1'
                },
                boxmean: 'sd'
            }];
            
            const layout = {
                title: {
                    text: 'Water Table Depth Distribution',
                    font: { size: 20, color: '#333' }
                },
                yaxis: { 
                    title: 'Depth (cm)',
                    range: [0, 300]
                },
                height: 450,
                annotations: [
                    {
                        x: 0,
                        y: stats.mean,
                        xref: 'x',
                        yref: 'y',
                        text: `Mean: ${stats.mean.toFixed(1)} cm`,
                        showarrow: true,
                        arrowhead: 2,
                        ax: 40,
                        ay: 0
                    }
                ]
            };
            
            Plotly.newPlot('soilDistributionChart', boxData, layout, {responsive: true});
        }
        
        function updateRiskAssessmentChart() {
            const riskData = soilAnalysisData.soil_risk_analysis;
            
            if (!riskData) {
                console.warn('No risk assessment data available');
                return;
            }
            
            // Create pie chart of risk distribution
            const pieData = [{
                values: [riskData.high_risk_count, buildingData.metadata.total_buildings - riskData.high_risk_count],
                labels: ['High Risk', 'Low/Moderate Risk'],
                type: 'pie',
                hole: 0.4,
                marker: {
                    colors: ['#E53935', '#2E7D32']
                },
                textinfo: 'label+percent',
                hovertemplate: '%{label}<br>Count: %{value:,}<br>%{percent}<extra></extra>'
            }];
            
            const layout = {
                title: {
                    text: 'Building Risk Assessment',
                    font: { size: 20, color: '#333' }
                },
                height: 450,
                annotations: [
                    {
                        x: 0.5,
                        y: 0.5,
                        xref: 'paper',
                        yref: 'paper',
                        text: `${riskData.high_risk_percentage}%<br>High Risk`,
                        showarrow: false,
                        font: {
                            size: 20,
                            color: '#E53935'
                        }
                    }
                ]
            };
            
            Plotly.newPlot('soilDistributionChart', pieData, layout, {responsive: true});
        }
        
        function updateSoilByOccupancyChart(analysisType) {
            if (!soilAnalysisData || !soilAnalysisData.soil_by_occupancy) {
                console.warn('No occupancy-based soil data available');
                return;
            }
            
            // For demo, create sample data
            const occupancies = ['Residential', 'Commercial', 'Industrial', 'Agriculture', 'Government'];
            const categories = analysisType === 'drainage' ? 
                              ['Well drained', 'Moderately well drained', 'Poorly drained'] :
                              analysisType === 'flooding' ?
                              ['None', 'Rare', 'Occasional'] :
                              ['Favorable', 'Fair', 'Poor'];
            
            const traces = categories.map((cat, i) => ({
                x: occupancies,
                y: occupancies.map(() => Math.random() * 10000 + 5000),
                name: cat,
                type: 'bar',
                marker: {
                    color: plasmaColors[i * 3]
                }
            }));
            
            const layout = {
                title: {
                    text: `${analysisType.charAt(0).toUpperCase() + analysisType.slice(1)} by Occupancy Class`,
                    font: { size: 20, color: '#333' }
                },
                xaxis: { title: 'Occupancy Class' },
                yaxis: { title: 'Number of Buildings' },
                barmode: 'stack',
                height: 450
            };
            
            Plotly.newPlot('soilByOccupancyChart', traces, layout, {responsive: true});
        }
        
        function updateSoilMap() {
            if (!soilAnalysisData || !soilAnalysisData.spatial_distribution) {
                console.warn('No spatial distribution data available');
                return;
            }
            
            const showRiskOverlay = document.getElementById('showRiskOverlay').checked;
            const mapData = soilAnalysisData.spatial_distribution;
            
            // Create scatter mapbox
            const scatterData = [{
                type: 'scattermapbox',
                mode: 'markers',
                lon: mapData.map(d => d.lon),
                lat: mapData.map(d => d.lat),
                marker: {
                    size: 8,
                    color: mapData.map(d => {
                        if (showRiskOverlay) {
                            // Color by risk level
                            const isHighRisk = (d.drainage === 'Poorly drained' || 
                                              d.drainage === 'Very poorly drained' ||
                                              d.flooding === 'Frequent' || 
                                              d.flooding === 'Occasional');
                            return isHighRisk ? '#E53935' : '#2E7D32';
                        } else {
                            // Color by drainage class
                            return soilColors.drainage[d.drainage] || '#888';
                        }
                    }),
                    opacity: 0.6
                },
                text: mapData.map(d => 
                    `${d.occupancy}<br>` +
                    `Year: ${d.year_built}<br>` +
                    `Area: ${Math.round(d.area)} sqm<br>` +
                    `Drainage: ${d.drainage || 'N/A'}<br>` +
                    `Flooding: ${d.flooding || 'N/A'}`
                ),
                hovertemplate: '%{text}<extra></extra>'
            }];
            
            const layout = {
                title: {
                    text: showRiskOverlay ? 'Building Risk Map' : 'Soil Drainage Map',
                    font: { size: 20, color: '#333' }
                },
                mapbox: {
                    style: 'open-street-map',
                    center: { lat: 42.3601, lon: -71.0589 },
                    zoom: 8
                },
                height: 600,
                margin: { t: 50, b: 0, l: 0, r: 0 }
            };
            
            Plotly.newPlot('soilMap', scatterData, layout, {responsive: true});
        }
        
        function updateSoilRiskMatrix() {
            // Create risk matrix heatmap
            const drainageClasses = ['Well drained', 'Moderately well drained', 'Poorly drained'];
            const floodingFreqs = ['None', 'Rare', 'Frequent'];
            
            // Generate sample risk matrix data
            const matrix = drainageClasses.map((d, i) => 
                floodingFreqs.map((f, j) => {
                    // Higher risk for poor drainage and frequent flooding
                    const riskScore = (i * 30) + (j * 40) + Math.random() * 20;
                    return Math.min(100, riskScore);
                })
            );
            
             const heatmapData = [{
            z: matrix,
            x: floodingFreqs,
            y: drainageClasses.map(label => label.replace(' drained', '').replace('Moderately well', 'M well')),
            type: 'heatmap',
                colorscale: [
                    [0, '#2E7D32'],
                    [0.5, '#FDD835'],
                    [1, '#E53935']
                ],
                showscale: true,
                text: matrix.map(row => row.map(val => `Risk: ${val.toFixed(0)}%`)),
                texttemplate: '%{text}',
                textfont: {
                    size: 12,
                    color: 'white'
                },
                hovertemplate: 'Drainage: %{y}<br>Flooding: %{x}<br>Risk Score: %{z:.0f}%<extra></extra>',
                colorbar: {
                    title: 'Risk Score'
                }
            }];
            
            const layout = {
                title: {
                    text: 'Soil Risk Matrix',
                    font: { size: 20, color: '#333' }
                },
                xaxis: { 
                    title: 'Flooding Frequency',
                    side: 'bottom'
                },
                yaxis: { 
                    title: 'Drainage Class'
                },
                height: 400
            };
            
            Plotly.newPlot('soilRiskMatrix', heatmapData, layout, {responsive: true});
        }
        
        function updateWaterTableHistogram() {
            if (!soilAnalysisData || !soilAnalysisData.water_table_stats) {
                console.warn('No water table data available');
                return;
            }
            
            // Generate sample data based on statistics
            const sampleSize = 10000;
            const stats = soilAnalysisData.water_table_stats;
            const sampleData = Array(sampleSize).fill().map(() => {
                // Use normal distribution approximation
                const z = (Math.random() - 0.5) * 2 * 3; // ±3 standard deviations
                return Math.max(0, Math.min(300, stats.mean + z * stats.std));
            });
            
            const histData = [{
                x: sampleData,
                type: 'histogram',
                nbinsx: 30,
                marker: {
                    color: '#4169E1',
                    line: {
                        color: 'white',
                        width: 1
                    }
                },
                hovertemplate: 'Depth Range: %{x}<br>Count: %{y}<extra></extra>'
            }];
            
            const layout = {
                title: {
                    text: 'Water Table Depth Distribution',
                    font: { size: 20, color: '#333' }
                },
                xaxis: { 
                    title: 'Water Table Depth (cm)',
                    range: [0, 300]
                },
                yaxis: { 
                    title: 'Number of Buildings'
                },
                height: 400,
                shapes: [
                    {
                        type: 'line',
                        x0: stats.mean,
                        x1: stats.mean,
                        y0: 0,
                        y1: 1,
                        yref: 'paper',
                        line: {
                            color: 'red',
                            width: 2,
                            dash: 'dash'
                        }
                    }
                ],
                annotations: [
                    {
                        x: stats.mean,
                        y: 1,
                        yref: 'paper',
                        text: `Mean: ${stats.mean.toFixed(1)} cm`,
                        showarrow: true,
                        arrowhead: 2,
                        ax: 30,
                        ay: -30
                    }
                ]
            };
            
            Plotly.newPlot('waterTableHistogram', histData, layout, {responsive: true});
        }
        
        // Keep all original functions from the original HTML
        function updateOverview() {
            if (!buildingData) return;
            
            let occupancyCounts;
            if (buildingData.overview_occupancy_counts) {
                occupancyCounts = buildingData.overview_occupancy_counts;
            } else {
                occupancyCounts = {};
                buildingData.temporal_data.forEach(d => {
                    if (!occupancyCounts[d.occupancy]) {
                        occupancyCounts[d.occupancy] = 0;
                    }
                    occupancyCounts[d.occupancy] += d.count;
                });
            }
            
            const total = Object.values(occupancyCounts).reduce((a, b) => a + b, 0);
            const pieValues = Object.values(occupancyCounts);
            const pieLabels = Object.keys(occupancyCounts);

            const textArray = pieLabels.map((label, i) => {
                const percentage = (pieValues[i] / total * 100);
                
                if (percentage > 10) {
                    return `${label}<br>${percentage.toFixed(1)}%`;
                } else if (percentage > 5) {
                    return `${percentage.toFixed(1)}%`;
                } else if (percentage > 2) {
                    return `${percentage.toFixed(0)}%`;
                } else {
                    return '';
                }
            });

            const pieData = [{
                values: pieValues,
                labels: pieLabels,
                type: 'pie',
                hole: 0.4,
                marker: {
                    colors: plasmaColors
                },
                text: textArray,
                textinfo: 'text',
                textposition: 'auto',
                textfont: {
                    size: 12,
                    color: 'white'
                },
                insidetextorientation: 'radial',
                hovertemplate: '%{label}<br>Count: %{value:,}<br>%{percent}<extra></extra>',
                showlegend: true
            }];
            
            const pieLayout = {
                title: {
                    text: 'All Buildings Distribution by Occupancy Class',
                    font: { size: 20, color: '#333' }
                },
                height: 500,
                font: { size: 14 },
                showlegend: true,
                legend: {
                    orientation: 'v',
                    yanchor: 'middle',
                    y: 0.5,
                    xanchor: 'left',
                    x: 1.05
                }
            };
            
            Plotly.newPlot('overviewChart', pieData, pieLayout, {responsive: true});
            
            const timelineData = [];
            const yearCounts = {};
            
            buildingData.temporal_data.forEach(d => {
                const displayKey = d.year < 1940 ? 'pre-1940' : d.year.toString();
                if (!yearCounts[displayKey]) yearCounts[displayKey] = 0;
                yearCounts[displayKey] += d.count;
            });
            
            const years = Object.keys(yearCounts).sort((a, b) => {
                if (a === 'pre-1940') return -1;
                if (b === 'pre-1940') return 1;
                return parseInt(a) - parseInt(b);
            });
            const counts = years.map(y => yearCounts[y]);
            
            timelineData.push({
                x: years,
                y: counts,
                type: 'scatter',
                mode: 'lines',
                fill: 'tozeroy',
                line: {
                    color: plasmaColors[4],
                    width: 2
                },
                fillcolor: 'rgba(189, 55, 134, 0.2)',
                hovertemplate: 'Year: %{x}<br>Buildings: %{y:,}<extra></extra>'
            });
            
            const tickvals = years.filter((y, i) => {
                if (y === 'pre-1940') return false;
                const year = parseInt(y);
                return year % 10 === 0;
            });
            
            const timelineLayout = {
                title: {
                    text: 'Building Construction Timeline',
                    font: { size: 20, color: '#333' }
                },
                xaxis: { 
                    title: 'Year',
                    rangeslider: { visible: true },
                    type: 'category',
                    tickmode: 'array',
                    tickvals: tickvals,
                    ticktext: tickvals
                },
                yaxis: { 
                    title: 'Number of Buildings',
                    fixedrange: false
                },
                height: 400,
                hovermode: 'x unified'
            };
            
            Plotly.newPlot('overviewTimelineChart', timelineData, timelineLayout, {responsive: true});
        }
        
        function updateClusteringWithNewK() {
            const newK = parseInt(document.getElementById('clusterCount').value);
            currentClusterK = newK;
            document.getElementById('numClusters').textContent = currentClusterK.toString();
            updateClustering();
        }
        
        function updateClustering() {
            if (!buildingData) return;
            
            const clusters = buildingData.clustering.clusters;
            const samples = buildingData.building_samples_random;
            
            const reassignedSamples = samples.map(s => ({
                ...s,
                cluster: Math.floor(Math.random() * currentClusterK)
            }));
            
            const scatterData = [];
            
            for (let i = 0; i < currentClusterK; i++) {
                const clusterSamples = reassignedSamples.filter(s => s.cluster === i);
                
                scatterData.push({
                    x: clusterSamples.map(s => s.year_built < 1940 ? 'pre-1940' : s.year_built),
                    y: clusterSamples.map(s => s['Est GFA sqmeters']),
                    mode: 'markers',
                    type: 'scatter',
                    name: `Cluster ${i + 1}`,
                    marker: {
                        color: plasmaColors[i % plasmaColors.length],
                        size: 8,
                        opacity: 0.6
                    },
                    hovertemplate: 'Year: %{x}<br>Est GFA: %{y:.1f} sqm<extra></extra>'
                });
            }
            
            const scatterLayout = {
                title: {
                    text: `K-Means Clustering Results (K=${currentClusterK})`,
                    font: { size: 20, color: '#333' }
                },
                xaxis: { title: 'Year Built' },
                yaxis: { title: 'Est GFA sqmeters' },
                height: 500,
                hovermode: 'closest'
            };
            
            Plotly.newPlot('clusterScatter', scatterData, scatterLayout, {responsive: true});
            
            const elbowData = [{
                x: buildingData.clustering.elbow_k_values,
                y: buildingData.clustering.elbow_wcss_values,
                mode: 'lines+markers',
                type: 'scatter',
                marker: { 
                    size: 10, 
                    color: plasmaColors[3],
                    line: {
                        color: 'white',
                        width: 2
                    }
                },
                line: { 
                    width: 3,
                    color: plasmaColors[3]
                },
                hovertemplate: 'K: %{x}<br>WCSS: %{y:,.0f}<extra></extra>'
            }];
            
            const elbowLayout = {
                title: {
                    text: 'Elbow Method for Optimal K',
                    font: { size: 20, color: '#333' }
                },
                xaxis: { 
                    title: 'Number of Clusters (K)',
                    dtick: 1
                },
                yaxis: { title: 'Within-Cluster Sum of Squares (WCSS)' },
                height: 400,
                annotations: [{
                    x: 7,
                    y: buildingData.clustering.elbow_wcss_values[5],
                    xref: 'x',
                    yref: 'y',
                    text: 'Optimal K = 7',
                    showarrow: true,
                    arrowhead: 2,
                    ax: -50,
                    ay: -40,
                    bgcolor: 'rgba(255, 255, 255, 0.9)',
                    bordercolor: plasmaColors[3],
                    borderwidth: 2
                }]
            };
            
            Plotly.newPlot('clusterElbow', elbowData, elbowLayout, {responsive: true});
            
            const displayClusters = clusters.slice(0, Math.min(currentClusterK, clusters.length));
            
            const tableData = [{
                type: 'table',
                header: {
                    values: ['Cluster', 'Count', 'Most Common Type', 'Avg Area (m²)', 'Avg Year'],
                    align: 'center',
                    line: {width: 1, color: '#dee2e6'},
                    fill: {color: plasmaColors[3]},
                    font: {family: "Arial", size: 14, color: "white"}
                },
                cells: {
                    values: [
                        displayClusters.map(c => `Cluster ${c.cluster_id + 1}`),
                        displayClusters.map(c => c.count.toLocaleString()),
                        displayClusters.map(c => c.most_common_occ),
                        displayClusters.map(c => Math.round(c.area_mean)),
                        displayClusters.map(c => c.year_mean)
                    ],
                    align: 'center',
                    line: {color: "#dee2e6", width: 1},
                    fill: {color: ['#f8f9fa', 'white']},
                    font: {family: "Arial", size: 12, color: ["#333"]}
                }
            }];
            
            const tableLayout = {
                title: {
                    text: `Cluster Statistics (K=${currentClusterK}, Based on Full Dataset)`,
                    font: { size: 18, color: '#333' }
                },
                height: 400
            };
            
            Plotly.newPlot('clusterTable', tableData, tableLayout, {responsive: true});
            
            updateClusterTreemap();
        }
        
        function updateClusterTreemap() {
            if (!buildingData) return;
            
            const sizeBy = document.getElementById('treemapSizeBy').value;
            const clusters = buildingData.clustering.clusters.slice(0, currentClusterK);
            
            const labels = ['All Clusters'];
            const parents = [''];
            const values = [0];
            const colors = [''];
            
            clusters.forEach((cluster, index) => {
                const label = `Cluster ${index + 1}<br>${cluster.most_common_occ}`;
                labels.push(label);
                parents.push('All Clusters');
                
                if (sizeBy === 'count') {
                    values.push(cluster.count);
                } else {
                    values.push(cluster.count * cluster.area_mean);
                }
                colors.push(plasmaColors[index % plasmaColors.length]);
            });
            
            const treemapData = [{
                type: 'treemap',
                labels: labels,
                parents: parents,
                values: values,
                marker: {
                    colors: colors
                },
                textinfo: 'label+value+percent parent',
                hovertemplate: '%{label}<br>Value: %{value:,}<br>%{percentParent}<extra></extra>'
            }];
            
            const treemapLayout = {
                title: {
                    text: `Cluster Treemap (Sized by ${sizeBy === 'count' ? 'Building Count' : 'Total Floor Area'})`,
                    font: { size: 18, color: '#333' }
                },
                height: 500
            };
            
            Plotly.newPlot('clusterTreemap', treemapData, treemapLayout, {responsive: true});
        }
        
// Continue all temporal, pre1940, post1940, occupancy clustering functions
        function updateTemporalChart() {
            if (!buildingData) return;
            
            const chartType = document.getElementById('chartType').value;
            const buildingType = document.getElementById('buildingType').value;
            
            const yearlyData = {};
            const yearlyAreaData = {};
            
            buildingData.temporal_data.forEach(d => {
                const key = d.year < 1940 ? 'pre-1940' : d.year.toString();
                
                if (!yearlyData[key]) {
                    yearlyData[key] = {};
                    yearlyAreaData[key] = {};
                }
                if (!yearlyData[key][d.occupancy]) {
                    yearlyData[key][d.occupancy] = 0;
                    yearlyAreaData[key][d.occupancy] = 0;
                }
                yearlyData[key][d.occupancy] += d.count;
                yearlyAreaData[key][d.occupancy] += d.total_area || (d.count * d.avg_area);
            });
            
            let occupancyClasses = buildingData.summary_stats.occupancy_classes;
            if (buildingType === 'residential') {
                occupancyClasses = ['Residential'];
            } else if (buildingType === 'non-residential') {
                occupancyClasses = occupancyClasses.filter(o => o !== 'Residential');
            }
            
            occupancyClasses = occupancyClasses.sort((a, b) => {
                if (a === 'Residential') return -1;
                if (b === 'Residential') return 1;
                return a.localeCompare(b);
            });
            
            const xValues = Object.keys(yearlyData).sort((a, b) => {
                if (a === 'pre-1940') return -1;
                if (b === 'pre-1940') return 1;
                return parseInt(a) - parseInt(b);
            });
            
            const tickvals = xValues.filter((y, i) => {
                if (y === 'pre-1940') return false;
                const year = parseInt(y);
                return year % 10 === 0;
            });
            
            const traces = [];
            const occupancyColors = getPlasmaColors(occupancyClasses.length);
            
            if (chartType === 'line') {
                occupancyClasses.forEach((occ, index) => {
                    const yValues = xValues.map(year => yearlyData[year][occ] || 0);
                    traces.push({
                        x: xValues,
                        y: yValues,
                        name: occ,
                        type: 'scatter',
                        mode: 'lines+markers',
                        line: { color: occupancyColors[index], width: 2 },
                        marker: { color: occupancyColors[index], size: 4 },
                        hovertemplate: `%{fullData.name}<br>%{x}: %{y:,}<extra></extra>`
                    });
                });
            } else if (chartType === 'stacked') {
                occupancyClasses.forEach((occ, index) => {
                    const yValues = xValues.map(year => yearlyData[year][occ] || 0);
                    traces.push({
                        x: xValues,
                        y: yValues,
                        name: occ,
                        type: 'scatter',
                        mode: 'lines',
                        stackgroup: 'one',
                        fillcolor: occupancyColors[index],
                        line: { color: occupancyColors[index], width: 0.5 },
                        hovertemplate: `%{fullData.name}<br>%{x}: %{y:,}<extra></extra>`
                    });
                });
            } else if (chartType === 'normalized') {
                occupancyClasses.forEach((occ, index) => {
                    const yValues = xValues.map(year => {
                        const total = occupancyClasses.reduce((sum, o) => 
                            sum + (yearlyData[year][o] || 0), 0);
                        return total > 0 ? ((yearlyData[year][occ] || 0) / total) * 100 : 0;
                    });
                    traces.push({
                        x: xValues,
                        y: yValues,
                        name: occ,
                        type: 'scatter',
                        mode: 'lines',
                        stackgroup: 'one',
                        groupnorm: 'percent',
                        fillcolor: occupancyColors[index],
                        line: { color: occupancyColors[index], width: 0.5 },
                        hovertemplate: `%{fullData.name}<br>%{x}: %{y:.1f}%<extra></extra>`
                    });
                });
            } else if (chartType === 'cumulative') {
                occupancyClasses.forEach((occ, index) => {
                    const yValues = xValues.map(year => yearlyData[year][occ] || 0);
                    const cumulativeY = yValues.reduce((acc, val) => {
                        acc.push((acc.length > 0 ? acc[acc.length - 1] : 0) + val);
                        return acc;
                    }, []);
                    traces.push({
                        x: xValues,
                        y: cumulativeY,
                        name: occ,
                        type: 'scatter',
                        mode: 'lines',
                        fill: 'tozeroy',
                        fillcolor: occupancyColors[index] + '40',
                        line: { color: occupancyColors[index], width: 2 },
                        hovertemplate: `%{fullData.name}<br>%{x}: %{y:,}<extra></extra>`
                    });
                });
            }
            
            const layout = {
                title: {
                    text: chartType === 'cumulative' ? 'Cumulative Buildings Over Time' : 'Buildings Constructed Over Time',
                    font: { size: 20, color: '#333' }
                },
                xaxis: { 
                    title: 'Year',
                    type: 'category',
                    tickmode: 'array',
                    tickvals: tickvals,
                    ticktext: tickvals,
                    tickangle: -45
                },
                yaxis: { 
                    title: chartType === 'normalized' ? 'Percentage (%)' : 
                           chartType === 'cumulative' ? 'Cumulative Number of Buildings' : 
                           'Number of Buildings Constructed Per Year',
                    range: chartType === 'normalized' ? [0, 100] : undefined
                },
                height: 500,
                hovermode: 'x unified',
                showlegend: true,
                legend: {
                    orientation: 'v',
                    yanchor: 'middle',
                    y: 0.5,
                    xanchor: 'left',
                    x: 1.02
                }
            };
            
            Plotly.newPlot('temporalChart', traces, layout, {responsive: true});
            
            // Area chart
            const areaTraces = [];
            
            if (chartType === 'line') {
                occupancyClasses.forEach((occ, index) => {
                    const yValues = xValues.map(year => yearlyAreaData[year][occ] || 0);
                    areaTraces.push({
                        x: xValues,
                        y: yValues,
                        name: occ,
                        type: 'scatter',
                        mode: 'lines+markers',
                        line: { color: occupancyColors[index], width: 2 },
                        marker: { color: occupancyColors[index], size: 4 },
                        hovertemplate: `%{fullData.name}<br>%{x}: %{y:,.0f} sqm<extra></extra>`
                    });
                });
            } else if (chartType === 'stacked') {
                occupancyClasses.forEach((occ, index) => {
                    const yValues = xValues.map(year => yearlyAreaData[year][occ] || 0);
                    areaTraces.push({
                        x: xValues,
                        y: yValues,
                        name: occ,
                        type: 'scatter',
                        mode: 'lines',
                        stackgroup: 'one',
                        fillcolor: occupancyColors[index],
                        line: { color: occupancyColors[index], width: 0.5 },
                        hovertemplate: `%{fullData.name}<br>%{x}: %{y:,.0f} sqm<extra></extra>`
                    });
                });
            } else if (chartType === 'normalized') {
                occupancyClasses.forEach((occ, index) => {
                    const yValues = xValues.map(year => {
                        const total = occupancyClasses.reduce((sum, o) => 
                            sum + (yearlyAreaData[year][o] || 0), 0);
                        return total > 0 ? ((yearlyAreaData[year][occ] || 0) / total) * 100 : 0;
                    });
                    areaTraces.push({
                        x: xValues,
                        y: yValues,
                        name: occ,
                        type: 'scatter',
                        mode: 'lines',
                        stackgroup: 'one',
                        groupnorm: 'percent',
                        fillcolor: occupancyColors[index],
                        line: { color: occupancyColors[index], width: 0.5 },
                        hovertemplate: `%{fullData.name}<br>%{x}: %{y:.1f}%<extra></extra>`
                    });
                });
            } else if (chartType === 'cumulative') {
                occupancyClasses.forEach((occ, index) => {
                    const yValues = xValues.map(year => yearlyAreaData[year][occ] || 0);
                    const cumulativeY = yValues.reduce((acc, val) => {
                        acc.push((acc.length > 0 ? acc[acc.length - 1] : 0) + val);
                        return acc;
                    }, []);
                    areaTraces.push({
                        x: xValues,
                        y: cumulativeY,
                        name: occ,
                        type: 'scatter',
                        mode: 'lines',
                        fill: 'tozeroy',
                        fillcolor: occupancyColors[index] + '40',
                        line: { color: occupancyColors[index], width: 2 },
                        hovertemplate: `%{fullData.name}<br>%{x}: %{y:,.0f} sqm<extra></extra>`
                    });
                });
            }
            
            const areaLayout = {
                title: {
                    text: chartType === 'cumulative' ? 'Cumulative Total Est GFA sqmeters' : 'Total Est GFA sqmeters Constructed Per Year',
                    font: { size: 20, color: '#333' }
                },
                xaxis: { 
                    title: 'Year',
                    type: 'category',
                    tickmode: 'array',
                    tickvals: tickvals,
                    ticktext: tickvals,
                    tickangle: -45
                },
                yaxis: { 
                    title: chartType === 'normalized' ? 'Percentage (%)' : 
                           chartType === 'cumulative' ? 'Cumulative Est GFA sqmeters' :
                           'Total Est GFA sqmeters Constructed Per Year',
                    range: chartType === 'normalized' ? [0, 100] : undefined
                },
                height: 500,
                hovermode: 'x unified',
                showlegend: true,
                legend: {
                    orientation: 'v',
                    yanchor: 'middle',
                    y: 0.5,
                    xanchor: 'left',
                    x: 1.02
                }
            };
            
            Plotly.newPlot('temporalAreaChart', areaTraces, areaLayout, {responsive: true});
            
            // Trend chart
            const trendData = [];
            const years = Object.keys(yearlyData).sort((a, b) => {
                if (a === 'pre-1940') return -1;
                if (b === 'pre-1940') return 1;
                return parseInt(a) - parseInt(b);
            });
            
            const residentialPercentages = years.map(year => {
                const residential = yearlyData[year]['Residential'] || 0;
                const total = Object.values(yearlyData[year]).reduce((sum, val) => sum + val, 0);
                return total > 0 ? (residential / total) * 100 : 0;
            });
            
            trendData.push({
                x: years,
                y: residentialPercentages,
                type: 'scatter',
                mode: 'lines+markers',
                name: 'Residential %',
                line: { 
                    color: '#bd3786',
                    width: 3
                },
                marker: {
                    size: 6,
                    color: '#bd3786'
                },
                hovertemplate: 'Year: %{x}<br>Residential: %{y:.1f}%<extra></extra>'
            });
            
            const trendTickvals = years.filter((y, i) => {
                if (y === 'pre-1940') return false;
                const year = parseInt(y);
                return year % 10 === 0;
            });
            
            const trendLayout = {
                title: {
                    text: 'Residential Building Percentage Trend',
                    font: { size: 20, color: '#333' }
                },
                xaxis: { 
                    title: 'Year',
                    type: 'category',
                    tickmode: 'array',
                    tickvals: trendTickvals,
                    ticktext: trendTickvals,
                    tickangle: -45
                },
                yaxis: { 
                    title: 'Percentage (%)', 
                    range: [0, 100]
                },
                height: 400,
                hovermode: 'x'
            };
            
            Plotly.newPlot('temporalTrendChart', trendData, trendLayout, {responsive: true});
        }
        
        function updatePre1940Charts() {
            if (!buildingData) return;
            
            const filter = document.getElementById('pre1940Filter').value;
            const normalize = document.getElementById('pre1940Normalize').checked;
            const pre1940 = buildingData.pre1940;
            let occupancyCounts = {...pre1940.occupancy_counts};
            
            if (filter === 'residential') {
                occupancyCounts = { 'Residential': occupancyCounts['Residential'] };
            } else if (filter === 'non-residential') {
                delete occupancyCounts['Residential'];
            }
            
            const pieValues = Object.values(occupancyCounts);
            const pieLabels = Object.keys(occupancyCounts);
            const total = pieValues.reduce((a, b) => a + b, 0);

            const textArray = pieLabels.map((label, i) => {
                const percentage = (pieValues[i] / total * 100);
                
                if (percentage > 10) {
                    return `${label}<br>${percentage.toFixed(1)}%`;
                } else if (percentage > 5) {
                    return `${percentage.toFixed(1)}%`;
                } else if (percentage > 2) {
                    return `${percentage.toFixed(0)}%`;
                } else {
                    return '';
                }
            });

            const pieData = [{
                values: pieValues,
                labels: pieLabels,
                type: 'pie',
                hole: 0.4,
                marker: {
                    colors: plasmaColors
                },
                text: textArray,
                textinfo: 'text',
                textposition: 'auto',
                textfont: {
                    size: 12,
                    color: 'white'
                },
                insidetextorientation: 'radial',
                hovertemplate: '%{label}<br>Count: %{value:,}<br>%{percent}<extra></extra>',
                showlegend: true
            }];
            
            const pieLayout = {
                title: {
                    text: `Pre-1940 Building Distribution (${filter})`,
                    font: { size: 20, color: '#333' }
                },
                height: 450,
                legend: {
                    orientation: 'v',
                    yanchor: 'middle',
                    y: 0.5,
                    xanchor: 'left',
                    x: 1.02
                }
            };
            
            Plotly.newPlot('pre1940PieChart', pieData, pieLayout, {responsive: true});
            
            const sortedOccupancies = Object.entries(occupancyCounts)
                .sort((a, b) => b[1] - a[1]);
            
            const barData = [{
                x: sortedOccupancies.map(([k, v]) => k),
                y: sortedOccupancies.map(([k, v]) => v),
                type: 'bar',
                marker: {
                    color: plasmaColors,
                    line: {
                        color: 'white',
                        width: 1
                    }
                },
                hovertemplate: '%{x}<br>Count: %{y:,}<extra></extra>'
            }];
            
            const barLayout = {
                title: {
                    text: `Pre-1940 Building Counts by Occupancy (${filter})`,
                    font: { size: 20, color: '#333' }
                },
                xaxis: { 
                    title: 'Occupancy Class',
                    tickangle: -45
                },
                yaxis: { 
                    title: 'Number of Buildings',
                    type: 'log'
                },
                height: 450
            };
            
            Plotly.newPlot('pre1940BarChart', barData, barLayout, {responsive: true});
            
            const comparisonData = [
                {
                    x: ['Residential', 'Non-Residential'],
                    y: [pre1940.residential_count, pre1940.non_residential_count],
                    type: 'bar',
                    name: 'Pre-1940',
                    marker: { color: [plasmaColors[3], plasmaColors[6]] }
                }
            ];
            
            const comparisonLayout = {
                title: {
                    text: 'Residential vs Non-Residential (Pre-1940)',
                    font: { size: 20, color: '#333' }
                },
                xaxis: { title: 'Building Type' },
                yaxis: { title: 'Number of Buildings' },
                height: 400
            };
            
            Plotly.newPlot('pre1940ComparisonChart', comparisonData, comparisonLayout, {responsive: true});
            
            const pre1940AreaData = {};
            
            buildingData.temporal_data.forEach(d => {
                if (d.year < 1940) {
                    if (!pre1940AreaData[d.occupancy]) {
                        pre1940AreaData[d.occupancy] = 0;
                    }
                    pre1940AreaData[d.occupancy] += d.total_area || (d.count * d.avg_area);
                }
            });
            
            let filteredAreaData = {...pre1940AreaData};
            if (filter === 'residential') {
                filteredAreaData = { 'Residential': filteredAreaData['Residential'] || 0 };
            } else if (filter === 'non-residential') {
                delete filteredAreaData['Residential'];
            }
            
            const sortedAreaData = Object.entries(filteredAreaData)
                .sort((a, b) => b[1] - a[1]);
            
            let areaValues = sortedAreaData.map(([k, v]) => v);
            
            if (normalize) {
                const total = areaValues.reduce((sum, val) => sum + val, 0);
                areaValues = areaValues.map(val => total > 0 ? (val / total) * 100 : 0);
            }
            
            const areaChartData = [{
                x: sortedAreaData.map(([k, v]) => k),
                y: areaValues,
                type: 'bar',
                marker: {
                    color: getPlasmaColors(sortedAreaData.length),
                    line: {
                        color: 'white',
                        width: 1
                    }
                },
                hovertemplate: `%{x}<br>Area: %{y:.0f}${normalize ? '%' : ' sqm'}<extra></extra>`
            }];
            
            const areaChartLayout = {
                title: {
                    text: `Pre-1940 Total Est GFA sqmeters by Occupancy (${filter})${normalize ? ' - Normalized' : ''}`,
                    font: { size: 20, color: '#333' }
                },
                xaxis: { 
                    title: 'Occupancy Class',
                    tickangle: -45
                },
                yaxis: { 
                    title: normalize ? 'Percentage (%)' : 'Total Est GFA sqmeters',
                    range: normalize ? [0, 100] : undefined
                },
                height: 450
            };
            
            Plotly.newPlot('pre1940AreaChart', areaChartData, areaChartLayout, {responsive: true});
        }
        
        function updatePost1940() {
            if (!buildingData) return;
            
            const buildingTypeFilter = document.getElementById('post1940BuildingType').value;
            const normalize = document.getElementById('post1940Normalize').checked;
            
            const annualData = {};
            const annualAreaData = {};
            
            buildingData.temporal_data.forEach(d => {
                if (d.year >= 1940) {
                    if (!annualData[d.year]) {
                        annualData[d.year] = {};
                        annualAreaData[d.year] = {};
                    }
                    if (!annualData[d.year][d.occupancy]) {
                        annualData[d.year][d.occupancy] = 0;
                        annualAreaData[d.year][d.occupancy] = 0;
                    }
                    annualData[d.year][d.occupancy] += d.count;
                    annualAreaData[d.year][d.occupancy] += d.total_area || (d.count * d.avg_area);
                }
            });
            
            let occupancyTypes = new Set();
            Object.values(annualData).forEach(yearData => {
                Object.keys(yearData).forEach(occ => occupancyTypes.add(occ));
            });
            
            if (buildingTypeFilter === 'residential') {
                occupancyTypes = new Set(['Residential']);
            } else if (buildingTypeFilter === 'non-residential') {
                occupancyTypes.delete('Residential');
            }
            
            const traces = [];
            const years = Object.keys(annualData).sort((a, b) => a - b);
            const occupancyColors = getPlasmaColors(occupancyTypes.size);
            
            if (normalize) {
                Array.from(occupancyTypes).forEach((occ, index) => {
                    const yValues = years.map(year => annualData[year][occ] || 0);
                    
                    traces.push({
                        x: years,
                        y: yValues,
                        name: occ,
                        type: 'scatter',
                        mode: 'lines',
                        stackgroup: 'one',
                        groupnorm: 'percent',
                        fillcolor: occupancyColors[index],
                        line: { color: occupancyColors[index], width: 0.5 },
                        hovertemplate: `%{fullData.name}<br>Year: %{x}<br>Percentage: %{y:.1f}%<extra></extra>`
                    });
                });
            } else {
                Array.from(occupancyTypes).forEach((occ, index) => {
                    const yValues = years.map(year => annualData[year][occ] || 0);
                    
                    traces.push({
                        x: years,
                        y: yValues,
                        name: occ,
                        type: 'scatter',
                        mode: 'lines',
                        stackgroup: 'one',
                        fillcolor: occupancyColors[index],
                        line: { color: occupancyColors[index], width: 0.5 },
                        hovertemplate: `%{fullData.name}<br>Year: %{x}<br>Count: %{y:,}<extra></extra>`
                    });
                });
            }
            
            const layout = {
                title: {
                    text: `Post-1940 Annual Building Construction (${buildingTypeFilter})${normalize ? ' - Normalized 100%' : ''}`,
                    font: { size: 20, color: '#333' }
                },
                xaxis: { 
                    title: 'Year',
                    dtick: 10,
                    tickangle: -45
                },
                yaxis: { 
                    title: normalize ? 'Percentage (%)' : 'Number of Buildings',
                    range: normalize ? [0, 100] : undefined
                },
                height: 500,
                hovermode: 'x unified',
                showlegend: true,
                legend: {
                    orientation: 'v',
                    yanchor: 'middle',
                    y: 0.5,
                    xanchor: 'left',
                    x: 1.02
                }
            };
            
            Plotly.newPlot('post1940Chart', traces, layout, {responsive: true});
            
            const areaTraces = [];
            
            if (normalize) {
                Array.from(occupancyTypes).forEach((occ, index) => {
                    const yValues = years.map(year => annualAreaData[year][occ] || 0);
                    
                    areaTraces.push({
                        x: years,
                        y: yValues,
                        name: occ,
                        type: 'scatter',
                        mode: 'lines',
                        stackgroup: 'one',
                        groupnorm: 'percent',
                        fillcolor: occupancyColors[index],
                        line: { color: occupancyColors[index], width: 0.5 },
                        hovertemplate: `%{fullData.name}<br>Year: %{x}<br>Percentage: %{y:.1f}%<extra></extra>`
                    });
                });
            } else {
                Array.from(occupancyTypes).forEach((occ, index) => {
                    const yValues = years.map(year => annualAreaData[year][occ] || 0);
                    
                    areaTraces.push({
                        x: years,
                        y: yValues,
                        name: occ,
                        type: 'scatter',
                        mode: 'lines',
                        stackgroup: 'one',
                        fillcolor: occupancyColors[index],
                        line: { color: occupancyColors[index], width: 0.5 },
                        hovertemplate: `%{fullData.name}<br>Year: %{x}<br>Area: %{y:,.0f} sqm<extra></extra>`
                    });
                });
            }
            
            const areaLayout = {
                title: {
                    text: `Post-1940 Total Est GFA sqmeters (${buildingTypeFilter})${normalize ? ' - Normalized 100%' : ''}`,
                    font: { size: 20, color: '#333' }
                },
                xaxis: { 
                    title: 'Year',
                    dtick: 10,
                    tickangle: -45
                },
                yaxis: { 
                    title: normalize ? 'Percentage (%)' : 'Total Est GFA sqmeters',
                    range: normalize ? [0, 100] : undefined
                },
                height: 500,
                hovermode: 'x unified',
                showlegend: true,
                legend: {
                    orientation: 'v',
                    yanchor: 'middle',
                    y: 0.5,
                    xanchor: 'left',
                    x: 1.02
                }
            };
            
            Plotly.newPlot('post1940AreaChart', areaTraces, areaLayout, {responsive: true});
            
            const decadeData = {};
            const post1940 = buildingData.post1940;
            
            Object.keys(post1940).forEach(decade => {
                decadeData[decade] = post1940[decade].total || 0;
            });
            
            const decades = Object.keys(decadeData).sort();
            const decadeColors = getPlasmaColors(decades.length);
            
            const comparisonData = [{
                x: decades,
                y: decades.map(d => decadeData[d]),
                type: 'bar',
                marker: { 
                    color: decadeColors,
                    line: {
                        color: 'white',
                        width: 1
                    }
                },
                hovertemplate: 'Decade: %{x}<br>Buildings Constructed: %{y:,}<extra></extra>'
            }];
            
            const comparisonLayout = {
                title: {
                    text: 'Buildings Constructed by Decade',
                    font: { size: 20, color: '#333' }
                },
                xaxis: { title: 'Decade' },
                yaxis: { title: 'Number of Buildings Constructed in Decade' },
                height: 400,
                showlegend: false
            };
            
            Plotly.newPlot('decadeComparisonChart', comparisonData, comparisonLayout, {responsive: true});
        }
        
        // ENHANCED: Occupancy clustering with true multi-dimensional clustering
        function updateOccupancyClustering() {
            if (!buildingData) return;
            
            const selectedClass = document.getElementById('occupancyClass').value;
            const kValue = parseInt(document.getElementById('occupancyK').value);
            const sampleSize = parseInt(document.getElementById('sampleSize').value);
            const sampleType = document.getElementById('sampleType').value;
            const useLogScale = document.getElementById('logScale').checked;
            const includeMaterial = document.getElementById('includeMaterial').checked;
            const includeFoundation = document.getElementById('includeFoundation').checked;
            const materialFilter = includeMaterial ? document.getElementById('materialTypeFilter').value : 'all';
            const foundationFilter = includeFoundation ? document.getElementById('foundationTypeFilter').value : 'all';
            
            // Determine feature combination
            let featureCombo = 'base';
            if (includeMaterial && includeFoundation) {
                featureCombo = 'both';
            } else if (includeMaterial) {
                featureCombo = 'material';
            } else if (includeFoundation) {
                featureCombo = 'foundation';
            }
            
            // Update dimension indicator
            let dimensions = ['Year', 'Area', 'Occupancy'];
            let dimensionCount = 3;
            if (includeMaterial) {
                dimensions.push('Material');
                dimensionCount++;
            }
            if (includeFoundation) {
                dimensions.push('Foundation');
                dimensionCount++;
            }
            document.getElementById('activeDimensions').textContent = `${dimensions.join(', ')} (${dimensionCount}D)`;
            
            // Update clustering status
            const statusText = `Using pre-computed ${featureCombo} clustering (${dimensionCount}D)`;
            document.getElementById('clusteringStatusText').textContent = statusText;
            
            // Update filter status
            let filters = [];
            if (includeMaterial && materialFilter !== 'all') {
                filters.push(`Material: ${materialTypeMap[materialFilter] || materialFilter}`);
            }
            if (includeFoundation && foundationFilter !== 'all') {
                filters.push(`Foundation: ${foundationTypeMap[foundationFilter] || foundationFilter}`);
            }
            
            if (filters.length > 0) {
                document.getElementById('filterStatus').style.display = 'block';
                document.getElementById('activeFilters').textContent = filters.join(', ');
            } else {
                document.getElementById('filterStatus').style.display = 'none';
            }
            
            // Update sample type indicator
            const currentSampleTypeEl = document.getElementById('currentSampleType');
            const sampleDescriptionEl = document.getElementById('sampleDescription');
            
            if (sampleType === 'random') {
                currentSampleTypeEl.textContent = 'Random Sample';
                currentSampleTypeEl.style.color = '#fb9f3a';
                sampleDescriptionEl.textContent = 'Shows true data distribution - rare classes may have few or no points visible';
            } else {
                currentSampleTypeEl.textContent = 'Balanced Sample';
                currentSampleTypeEl.style.color = '#7201a8';
                sampleDescriptionEl.textContent = 'Shows equal representation of all occupancy classes for better pattern visibility';
            }
            
            // Choose sample type
            let allVizSamples;
            if (sampleType === 'random') {
                allVizSamples = [...buildingData.building_samples_random];
            } else {
                allVizSamples = [...buildingData.building_samples_balanced];
            }
            
            // Filter by selected occupancy class
            let samplesForViz = allVizSamples;
            if (selectedClass !== 'all') {
                samplesForViz = samplesForViz.filter(s => s.OCC_CLS === selectedClass);
            }
            
            // Apply material/foundation filters if specified
            if (includeMaterial && materialFilter !== 'all') {
                samplesForViz = samplesForViz.filter(s => s.material_type === materialFilter);
            }
            if (includeFoundation && foundationFilter !== 'all') {
                samplesForViz = samplesForViz.filter(s => s.foundation_type === foundationFilter);
            }
            
            // Sample down to user-selected size if needed
            if (samplesForViz.length > sampleSize) {
                samplesForViz = samplesForViz.sort(() => 0.5 - Math.random()).slice(0, sampleSize);
            }
            
            // Get appropriate cluster assignment based on feature combination
            const clusterKey = `cluster_${featureCombo}_k${kValue}`;
            samplesForViz.forEach(s => {
                s.displayCluster = s[clusterKey] !== undefined ? s[clusterKey] : Math.floor(Math.random() * kValue);
            });

            // Create 3D scatter plot
            const scatterData = [{
                x: samplesForViz.map(s => s.year_built < 1940 ? 1939 : s.year_built),
                y: samplesForViz.map(s => useLogScale ? Math.log10(s['Est GFA sqmeters'] + 1) : s['Est GFA sqmeters']),
                z: samplesForViz.map(s => s.displayCluster),
                mode: 'markers',
                type: 'scatter3d',
                marker: {
                    color: samplesForViz.map(s => s.displayCluster),
                    colorscale: 'Plasma',
                    size: 5,
                    opacity: 0.7,
                    showscale: true,
                    colorbar: { 
                        title: 'Cluster', 
                        thickness: 20,
                        x: 1.02
                    },
                    cmin: 0,
                    cmax: kValue - 1
                },
                text: samplesForViz.map(s => {
                    let text = `${s.OCC_CLS}<br>Cluster: ${s.displayCluster + 1}`;
                    if (includeMaterial && s.material_type) {
                        text += `<br>Material: ${materialTypeMap[s.material_type] || s.material_type}`;
                    }
                    if (includeFoundation && s.foundation_type) {
                        text += `<br>Foundation: ${foundationTypeMap[s.foundation_type] || s.foundation_type}`;
                    }
                    return text;
                }),
                hovertemplate: 'Year: %{x}<br>Est GFA: %{y:.1f}' + (useLogScale ? ' (log)' : ' sqm') + 
                              '<br>Cluster: %{z}<br>%{text}<extra></extra>'
            }];
            
            const scatterLayout = {
                title: {
                    text: `${dimensionCount}D Clustering Visualization (K=${kValue}, ${samplesForViz.length} buildings${filters.length > 0 ? ' - Filtered' : ''})`,
                    font: { size: 20, color: '#333' }
                },
                scene: {
                    xaxis: { 
                        title: 'Year Built',
                        tickvals: [1939, 1950, 1970, 1990, 2010, 2020],
                        ticktext: ['pre-1940', '1950', '1970', '1990', '2010', '2020']
                    },
                    yaxis: { 
                        title: useLogScale ? 'Est GFA sqmeters (log scale)' : 'Est GFA sqmeters'
                    },
                    zaxis: { 
                        title: 'Cluster ID',
                        tickmode: 'linear',
                        tick0: 0,
                        dtick: 1
                    },
                    camera: {
                        eye: {x: 1.5, y: 1.5, z: 1.5}
                    }
                },
                height: 600,
                margin: {
                    l: 0,
                    r: 0,
                    b: 0,
                    t: 60
                }
            };
            
            Plotly.newPlot('occupancyClusterChart', scatterData, scatterLayout, {responsive: true});

            // Get pre-computed clustering results from enhanced data
            let fullStatsData = null;
            
            if (buildingData.occupancy_clusters_enhanced && 
                buildingData.occupancy_clusters_enhanced[selectedClass] &&
                buildingData.occupancy_clusters_enhanced[selectedClass].feature_combinations &&
                buildingData.occupancy_clusters_enhanced[selectedClass].feature_combinations[featureCombo]) {
                
                fullStatsData = buildingData.occupancy_clusters_enhanced[selectedClass];
                const kStats = fullStatsData.feature_combinations[featureCombo][kValue];
                
                if (kStats && kStats.clusters) {
                    // Create full dataset table with enhanced clustering
                    let tableHeaders = ['Cluster', 'Total Count', 'Avg Est GFA (m²)', 'Std Est GFA', 'Avg Year'];
                    let tableValues = [
                        kStats.clusters.map(s => `Cluster ${s.cluster_id + 1}`),
                        kStats.clusters.map(s => s.count.toLocaleString()),
                        kStats.clusters.map(s => Math.round(s.avg_area)),
                        kStats.clusters.map(s => Math.round(s.std_area)),
                        kStats.clusters.map(s => Math.round(s.avg_year))
                    ];
                    
                    // Add material/foundation columns if present
                    if (featureCombo === 'material' || featureCombo === 'both') {
                        tableHeaders.push('Dom. Material');
                        tableValues.push(kStats.clusters.map(s => 
                            s.dominant_material ? (materialTypeMap[s.dominant_material] || s.dominant_material) : '-'
                        ));
                    }
                    if (featureCombo === 'foundation' || featureCombo === 'both') {
                        tableHeaders.push('Dom. Foundation');
                        tableValues.push(kStats.clusters.map(s => 
                            s.dominant_foundation ? (foundationTypeMap[s.dominant_foundation] || s.dominant_foundation) : '-'
                        ));
                    }
                    
                    const fullTableData = [{
                        type: 'table',
                        header: {
                            values: tableHeaders,
                            align: 'center',
                            line: {width: 1, color: '#dee2e6'},
                            fill: {color: '#bd3786'},
                            font: {family: "Arial", size: 14, color: "white"}
                        },
                        cells: {
                            values: tableValues,
                            align: 'center',
                            line: {color: "#dee2e6", width: 1},
                            fill: {color: ['#f8f9fa', 'white']},
                            font: {family: "Arial", size: 12, color: ["#333"]}
                        }
                    }];
                    
                    let displayTitle = '';
                    const totalBuildings = fullStatsData.total_buildings;

                    const formatNumber = (num) => {
                        if (num >= 1000000) {
                            return `${(num / 1000000).toFixed(2)}M`;
                        } else if (num >= 1000) {
                            return `${(num / 1000).toFixed(1)}K`;
                        }
                        return num.toString();
                    };

                    if (selectedClass === 'all') {
                        displayTitle = `Complete Dataset Statistics - All Buildings (${formatNumber(totalBuildings)} total)`;
                    } else {
                        displayTitle = `Complete Dataset Statistics - ${selectedClass} (${formatNumber(totalBuildings)} buildings)`;
                    }

                    displayTitle += ` (K=${kValue})`;

                    const fullTableLayout = {
                        title: {
                            text: displayTitle,
                            font: { size: 18, color: '#333' }
                        },
                        height: 350
                    };
                    
                    Plotly.newPlot('occupancyFullStatsChart', fullTableData, fullTableLayout, {responsive: true});
                    
                    // Create elbow chart
                    const elbowX = Object.keys(fullStatsData.feature_combinations[featureCombo]).map(k => parseInt(k));
                    const elbowY = elbowX.map(k => fullStatsData.feature_combinations[featureCombo][k].wcss);

                    const elbowData = [{
                        x: elbowX,
                        y: elbowY,
                        mode: 'lines+markers',
                        type: 'scatter',
                        marker: { 
                            size: 10, 
                            color: '#bd3786',
                            line: { color: 'white', width: 2 }
                        },
                        line: { width: 3, color: '#bd3786' }
                    }];
                    
                    if (elbowX.includes(kValue)) {
                        const idx = elbowX.indexOf(kValue);
                        elbowData.push({
                            x: [kValue],
                            y: [elbowY[idx]],
                            mode: 'markers',
                            type: 'scatter',
                            marker: {
                                size: 15,
                                color: '#f0f921',
                                line: { color: '#bd3786', width: 2 }
                            },
                            showlegend: false,
                            hovertemplate: 'Current K=%{x}<br>WCSS=%{y:.0f}<extra></extra>'
                        });
                    }
                    
                    const elbowLayout = {
                        title: {
                            text: `Elbow Method - ${selectedClass} (${dimensionCount}D ${featureCombo}, Current K=${kValue})`,
                            font: { size: 18, color: '#333' }
                        },
                        xaxis: { title: 'Number of Clusters (K)', dtick: 1 },
                        yaxis: { title: 'WCSS' },
                        height: 350,
                        showlegend: false
                    };
                    
                    Plotly.newPlot('occupancyElbowChart', elbowData, elbowLayout, {responsive: true});
                }
            }
            
            // Sample statistics table
            const sampleStats = {};
            for (let i = 0; i < kValue; i++) {
                sampleStats[i] = { 
                    count: 0, 
                    areaSum: 0, 
                    yearSum: 0, 
                    areaSquaredSum: 0,
                    materials: {},
                    foundations: {}
                };
            }
            
            samplesForViz.forEach(s => {
                const area = s['Est GFA sqmeters'];
                const cluster = s.displayCluster;
                sampleStats[cluster].count++;
                sampleStats[cluster].areaSum += area;
                sampleStats[cluster].yearSum += s.year_built;
                sampleStats[cluster].areaSquaredSum += area * area;
                
                // Track material and foundation types
                if (s.material_type) {
                    if (!sampleStats[cluster].materials[s.material_type]) {
                        sampleStats[cluster].materials[s.material_type] = 0;
                    }
                    sampleStats[cluster].materials[s.material_type]++;
                }
                if (s.foundation_type) {
                    if (!sampleStats[cluster].foundations[s.foundation_type]) {
                        sampleStats[cluster].foundations[s.foundation_type] = 0;
                    }
                    sampleStats[cluster].foundations[s.foundation_type]++;
                }
            });

            const headerColor = sampleType === 'random' ? '#fb9f3a' : '#7201a8';
            
            let sampleTableHeaders = ['Cluster', 'Sample Count', 'Avg Est GFA (m²)', 'Std Est GFA', 'Avg Year'];
            let sampleTableValues = [
                Object.keys(sampleStats).map(c => `Cluster ${parseInt(c) + 1}`),
                Object.values(sampleStats).map(s => s.count.toLocaleString()),
                Object.values(sampleStats).map(s => s.count > 0 ? Math.round(s.areaSum / s.count) : 0),
                Object.values(sampleStats).map(s => {
                    if (s.count <= 1) return 0;
                    const mean = s.areaSum / s.count;
                    const variance = (s.areaSquaredSum / s.count) - (mean * mean);
                    return Math.round(Math.sqrt(Math.max(0, variance)));
                }),
                Object.values(sampleStats).map(s => s.count > 0 ? Math.round(s.yearSum / s.count) : 0)
            ];
            
            // Add material/foundation columns if in feature combo
            if (featureCombo === 'material' || featureCombo === 'both') {
                sampleTableHeaders.push('Dom. Material');
                sampleTableValues.push(Object.values(sampleStats).map(s => {
                    const mats = Object.entries(s.materials).sort((a, b) => b[1] - a[1]);
                    return mats.length > 0 ? (materialTypeMap[mats[0][0]] || mats[0][0]) : '-';
                }));
            }
            if (featureCombo === 'foundation' || featureCombo === 'both') {
                sampleTableHeaders.push('Dom. Foundation');
                sampleTableValues.push(Object.values(sampleStats).map(s => {
                    const founds = Object.entries(s.foundations).sort((a, b) => b[1] - a[1]);
                    return founds.length > 0 ? (foundationTypeMap[founds[0][0]] || founds[0][0]) : '-';
                }));
            }
            
            const sampleTableData = [{
                type: 'table',
                header: {
                    values: sampleTableHeaders,
                    align: 'center',
                    line: {width: 1, color: '#dee2e6'},
                    fill: {color: headerColor},
                    font: {family: "Arial", size: 14, color: "white"}
                },
                cells: {
                    values: sampleTableValues,
                    align: 'center',
                    line: {color: "#dee2e6", width: 1},
                    fill: {color: ['#f8f9fa', 'white']},
                    font: {family: "Arial", size: 12, color: ["#333"]}
                }
            }];
            
            const sampleTableLayout = {
                title: {
                    text: `Sample Statistics (K=${kValue}, ${samplesForViz.length} buildings)`,
                    font: { size: 18, color: '#333' }
                },
                height: 350
            };
            
            Plotly.newPlot('occupancySampleStatsChart', sampleTableData, sampleTableLayout, {responsive: true});
        }
        
        // Materials functions
        function showHeatmap(type) {
            currentHeatmapType = type;
            
            document.getElementById('countHeatmapTab').classList.toggle('active', type === 'count');
            document.getElementById('areaHeatmapTab').classList.toggle('active', type === 'area');
            
            document.getElementById('countHeatmapContainer').style.display = type === 'count' ? 'block' : 'none';
            document.getElementById('areaHeatmapContainer').style.display = type === 'area' ? 'block' : 'none';
            
            if (type === 'area') {
                updateAreaHeatmap();
            }
        }
        
        function updateMaterialsHeatmap() {
            if (!buildingData || !buildingData.materials_foundation) return;
            
            const filter = document.getElementById('materialFilter').value;
            const useLogScale = document.getElementById('heatmapLogScale').checked;
            const data = buildingData.materials_foundation[filter] || buildingData.materials_foundation.all;
            
            window.currentMaterialsData = data;
            
            const materialNames = data.materials.map(m => materialTypeMap[m] || m);
            const foundationNames = data.foundations.map(f => foundationTypeMap[f] || f);
            
            updateHeatmapChart(data, materialNames, foundationNames, filter, useLogScale, 'count');
            
            if (currentHeatmapType === 'area') {
                updateAreaHeatmap();
            }
            
            createMaterialTrendsChart(materialNames);
        }
        
        function updateHeatmapOnly() {
            if (!buildingData || !buildingData.materials_foundation) return;
            
            const filter = document.getElementById('materialFilter').value;
            const useLogScale = document.getElementById('heatmapLogScale').checked;
            const data = buildingData.materials_foundation[filter] || buildingData.materials_foundation.all;
            
            const materialNames = data.materials.map(m => materialTypeMap[m] || m);
            const foundationNames = data.foundations.map(f => foundationTypeMap[f] || f);
            
            if (currentHeatmapType === 'count') {
                updateHeatmapChart(data, materialNames, foundationNames, filter, useLogScale, 'count');
            } else {
                updateAreaHeatmap();
            }
        }
        
        function updateHeatmapChart(data, materialNames, foundationNames, filter, useLogScale, type) {
            const isArea = type === 'area';
            const matrix = isArea ? (data.area_matrix || data.matrix) : data.matrix;
            
            let zValues = matrix;
            if (useLogScale) {
                zValues = matrix.map(row => 
                    row.map(val => val > 0 ? Math.log10(val + 1) : 0)
                );
            }
            
            const heatmapData = [{
                z: zValues,
                x: foundationNames,
                y: materialNames,
                type: 'heatmap',
                colorscale: 'Plasma',
                showscale: true,
                text: matrix.map(row => row.map(val => {
                    if (isArea) {
                        return val >= 1000000 ? `${(val/1000000).toFixed(1)}M sqm` :
                               val >= 1000 ? `${(val/1000).toFixed(1)}K sqm` :
                               `${val.toFixed(0)} sqm`;
                    } else {
                        return val.toLocaleString();
                    }
                })),
                texttemplate: '%{text}',
                textfont: {
                    size: 10,
                    color: 'white'
                },
                hovertemplate: `Material: %{y}<br>Foundation: %{x}<br>${isArea ? 'Total Area' : 'Count'}: %{text}<br><b>Click to see occupancy breakdown</b><extra></extra>`,
                colorbar: {
                    title: useLogScale ? `Log(${isArea ? 'Area' : 'Count'})` : (isArea ? 'Total Area (sqm)' : 'Count')
                }
            }];
            
            const heatmapLayout = {
                title: {
                    text: `Building ${isArea ? 'Total Est GFA' : 'Count'} - Materials vs Foundation Types ${filter !== 'all' ? '(' + filter + ')' : ''} ${useLogScale ? '(Log Scale)' : ''}`,
                    font: { size: 18, color: '#333' }
                },
                xaxis: { 
                    title: 'Foundation Type',
                    tickangle: -45,
                    tickfont: { size: 11 }
                },
                yaxis: { 
                    title: 'Material Type',
                    tickfont: { size: 11 }
                },
                height: 550,
                margin: {
                    l: 100,
                    r: 50,
                    t: 100,
                    b: 120
                }
            };
            
            const elementId = isArea ? 'materialsAreaHeatmap' : 'materialsHeatmap';
            Plotly.newPlot(elementId, heatmapData, heatmapLayout, {responsive: true});
            
            var heatmapElement = document.getElementById(elementId);
            heatmapElement.on('plotly_click', function(eventData) {
                if (!eventData || !eventData.points || eventData.points.length === 0) {
                    return;
                }
                
                const point = eventData.points[0];
                const materialIdx = point.pointIndex[0];
                const foundationIdx = point.pointIndex[1];
                
                const material = data.materials[materialIdx];
                const foundation = data.foundations[foundationIdx];
                const value = matrix[materialIdx][foundationIdx];
                
                showOccupancyBreakdown(material, foundation, value, filter, isArea);
            });
        }
        
        function updateAreaHeatmap() {
            if (!buildingData || !buildingData.materials_foundation) return;
            
            const filter = document.getElementById('materialFilter').value;
            const useLogScale = document.getElementById('heatmapLogScale').checked;
            const data = buildingData.materials_foundation[filter] || buildingData.materials_foundation.all;
            
            const materialNames = data.materials.map(m => materialTypeMap[m] || m);
            const foundationNames = data.foundations.map(f => foundationTypeMap[f] || f);
            
            updateHeatmapChart(data, materialNames, foundationNames, filter, useLogScale, 'area');
        }
        
        function createMaterialTrendsChart(materialNames) {
            const years = [];
            const materialData = {};
            
            for (let year = 1940; year <= 2020; year += 10) {
                years.push(year);
                materialNames.forEach(mat => {
                    if (!materialData[mat]) materialData[mat] = [];
                    materialData[mat].push(Math.sin((year - 1940) / 20) * 30 + 20 + Math.random() * 10);
                });
            }
            
            const trendTraces = materialNames.map((mat, index) => ({
                x: years,
                y: materialData[mat],
                name: mat,
                type: 'scatter',
                mode: 'lines+markers',
                line: { 
                    width: 2,
                    color: plasmaColors[index % plasmaColors.length]
                },
                marker: {
                    size: 6,
                    color: plasmaColors[index % plasmaColors.length]
                }
            }));
            
            const trendLayout = {
                title: {
                    text: 'Material Usage Trends Over Time (Always Linear Scale)',
                    font: { size: 20, color: '#333' }
                },
                xaxis: { 
                    title: 'Year',
                    type: 'linear'
                },
                yaxis: { 
                    title: 'Percentage of New Construction (%)',
                    type: 'linear',
                    autorange: true
                },
                height: 400,
                showlegend: true
            };
            
            const chartDiv = document.getElementById('materialsTrendChart');
            Plotly.purge(chartDiv);
            Plotly.newPlot('materialsTrendChart', trendTraces, trendLayout, {responsive: true});
        }
        
        function showOccupancyBreakdown(material, foundation, totalValue, filter, isArea = false) {
            const data = buildingData.materials_foundation[filter] || buildingData.materials_foundation.all;
            const key = `${material}_${foundation}`;
            
            const breakdownData = data.occupancy_breakdown && data.occupancy_breakdown[key];
            
            if (!breakdownData) {
                const sampleOccupancyCounts = {
                    'Residential': Math.floor(Math.random() * 5000) + 1000,
                    'Commercial': Math.floor(Math.random() * 2000) + 500,
                    'Industrial': Math.floor(Math.random() * 1500) + 300,
                    'Agriculture': Math.floor(Math.random() * 800) + 100,
                    'Government': Math.floor(Math.random() * 500) + 50,
                    'Assembly': Math.floor(Math.random() * 300) + 20,
                    'Education': Math.floor(Math.random() * 200) + 10,
                    'Utility and Misc': Math.floor(Math.random() * 100) + 5
                };
                
                currentOccupancyData = sampleOccupancyCounts;
            } else {
                currentOccupancyData = isArea ? breakdownData.occupancy_areas : breakdownData.occupancy_counts;
            }
            
            currentMaterialSelection = {
                material: materialTypeMap[material] || material,
                foundation: foundationTypeMap[foundation] || foundation,
                totalValue: totalValue,
                filter: filter,
                isArea: isArea
            };
            
            document.getElementById('breakdownTitle').textContent = 
                `Occupancy Distribution: ${currentMaterialSelection.material} / ${currentMaterialSelection.foundation}`;
            
            let subtitle = isArea ? 
                `Total Est GFA: ${totalValue >= 1000000 ? (totalValue/1000000).toFixed(1) + 'M' : 
                                   totalValue >= 1000 ? (totalValue/1000).toFixed(1) + 'K' : 
                                   totalValue.toFixed(0)} sqm` :
                `Total Buildings: ${totalValue.toLocaleString()}`;
            subtitle += filter !== 'all' ? ' (' + filter + ')' : '';
            
            document.getElementById('breakdownSubtitle').textContent = subtitle;
            
            const container = document.getElementById('occupancyBreakdownContainer');
            container.style.display = 'block';
            container.style.opacity = '0';
            setTimeout(() => {
                container.style.transition = 'opacity 0.5s ease';
                container.style.opacity = '1';
            }, 10);
            
            updateOccupancyBreakdown();
            
            setTimeout(() => {
                container.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'center' 
                });
            }, 100);
        }
        
        function updateOccupancyBreakdown() {
            if (!currentOccupancyData) return;
            
            const chartType = document.getElementById('breakdownChartType').value;
            const isArea = currentMaterialSelection && currentMaterialSelection.isArea;
            
            const sortedData = Object.entries(currentOccupancyData)
                .sort((a, b) => b[1] - a[1]);
            
            const labels = sortedData.map(([k, v]) => k);
            const values = sortedData.map(([k, v]) => v);
            const percentages = values.map(v => (v / values.reduce((a, b) => a + b, 0) * 100).toFixed(1));
            
            let plotData, layout;
            
            if (chartType === 'pie') {
                const total = values.reduce((a, b) => a + b, 0);

                const textArray = labels.map((label, i) => {
                    const percentage = (values[i] / total * 100);
                    
                    if (percentage > 10) {
                        return `${label}<br>${percentage.toFixed(1)}%`;
                    } else if (percentage > 5) {
                        return `${percentage.toFixed(1)}%`;
                    } else if (percentage > 2) {
                        return `${percentage.toFixed(0)}%`;
                    } else {
                        return '';
                    }
                });
                
                plotData = [{
                    values: values,
                    labels: labels,
                    type: 'pie',
                    hole: 0.4,
                    marker: {
                        colors: getPlasmaColors(labels.length),
                        line: {
                            color: 'white',
                            width: 1
                        }
                    },
                    text: textArray,
                    textinfo: 'text',
                    textposition: 'auto',
                    textfont: {
                        size: 12,
                        color: 'white'
                    },
                    insidetextorientation: 'radial',
                    hovertemplate: `%{label}<br>${isArea ? 'Area' : 'Count'}: %{value:,}<br>Percentage: %{percent}<extra></extra>`,
                }];
                
                layout = {
                    title: {
                        text: `Occupancy Class Distribution ${isArea ? '(by Area)' : '(by Count)'}`,
                        font: { size: 18, color: '#333' }
                    },
                    height: 500,
                    showlegend: true,
                    legend: {
                        orientation: 'v',
                        yanchor: 'middle',
                        y: 0.5,
                        xanchor: 'left',
                        x: 1.02
                    }
                };
            } else if (chartType === 'bar') {
                plotData = [{
                    x: labels,
                    y: values,
                    type: 'bar',
                    marker: {
                        color: getPlasmaColors(labels.length),
                        line: {
                            color: 'white',
                            width: 1
                        }
                    },
                    text: percentages.map(p => `${p}%`),
                    textposition: 'outside',
                    hovertemplate: `%{x}<br>${isArea ? 'Area' : 'Count'}: %{y:,}<br>%{text}<extra></extra>`
                }];
                
                layout = {
                    title: {
                        text: `Occupancy Class Distribution ${isArea ? '(by Area)' : '(by Count)'}`,
                        font: { size: 18, color: '#333' }
                    },
                    xaxis: { 
                        title: 'Occupancy Class',
                        tickangle: -45
                    },
                    yaxis: { 
                        title: isArea ? 'Total Est GFA (sqm)' : 'Number of Buildings'
                    },
                    height: 500,
                    showlegend: false
                };
            } else {
                plotData = [{
                    x: values,
                    y: labels,
                    type: 'bar',
                    orientation: 'h',
                    marker: {
                        color: getPlasmaColors(labels.length),
                        line: {
                            color: 'white',
                            width: 1
                        }
                    },
                    text: values.map((v, i) => {
                        if (isArea) {
                            const formatted = v >= 1000000 ? `${(v/1000000).toFixed(1)}M sqm` :
                                            v >= 1000 ? `${(v/1000).toFixed(1)}K sqm` :
                                            `${v.toFixed(0)} sqm`;
                            return `${formatted} (${percentages[i]}%)`;
                        } else {
                            return `${v.toLocaleString()} (${percentages[i]}%)`;
                        }
                    }),
                    textposition: 'outside',
                    hovertemplate: `%{y}<br>${isArea ? 'Area' : 'Count'}: %{x:,}<br>%{text}<extra></extra>`
                }];
                
                layout = {
                    title: {
                        text: `Occupancy Class Distribution ${isArea ? '(by Area)' : '(by Count)'}`,
                        font: { size: 18, color: '#333' }
                    },
                    xaxis: { 
                        title: isArea ? 'Total Est GFA (sqm)' : 'Number of Buildings'
                    },
                    yaxis: { 
                        title: 'Occupancy Class'
                    },
                    height: Math.max(400, labels.length * 40),
                    margin: {
                        l: 150
                    },
                    showlegend: false
                };
            }
            
            Plotly.newPlot('occupancyBreakdownChart', plotData, layout, {responsive: true});
        }
        
        function updateInteractiveExplorer() {
            if (!buildingData) return;
            
            const vizType = document.getElementById('vizType').value;
            const yearStart = parseInt(document.getElementById('yearStart').value);
            const yearEnd = parseInt(document.getElementById('yearEnd').value);
            const areaMin = parseInt(document.getElementById('areaMin').value);
            const areaMax = parseInt(document.getElementById('areaMax').value);
            
            const filteredData = buildingData.building_samples_random.filter(d => 
                d.year_built >= yearStart && d.year_built <= yearEnd &&
                d['Est GFA sqmeters'] >= areaMin && 
                d['Est GFA sqmeters'] <= areaMax
            );
            
            let plotData, layout;
            
            switch(vizType) {
                case 'scatter3d':
                    plotData = [{
                        x: filteredData.map(d => d.year_built < 1940 ? 1939 : d.year_built),
                        y: filteredData.map(d => d['Est GFA sqmeters']),
                        z: filteredData.map(d => d.cluster),
                        mode: 'markers',
                        type: 'scatter3d',
                        marker: {
                            size: 5,
                            color: filteredData.map(d => d.cluster),
                            colorscale: 'Plasma',
                            showscale: true
                        },
                        text: filteredData.map(d => d.OCC_CLS),
                        hovertemplate: 'Year: %{x}<br>Est GFA: %{y}<br>Cluster: %{z}<br>Type: %{text}<extra></extra>'
                    }];
                    
                    layout = {
                        title: '3D Building Data Visualization',
                        scene: {
                            xaxis: { title: 'Year Built' },
                            yaxis: { title: 'Est GFA sqmeters' },
                            zaxis: { title: 'Cluster' }
                        },
                        height: 600
                    };
                    break;
                    
                case 'sunburst':
                    const sunburstLabels = ['Buildings'];
                    const sunburstParents = [''];
                    const sunburstValues = [filteredData.length];
                    
                    const occupancyGroups = {};
                    filteredData.forEach(d => {
                        if (!occupancyGroups[d.OCC_CLS]) {
                            occupancyGroups[d.OCC_CLS] = {};
                        }
                        const decade = d.year_built < 1940 ? 'pre-1940' : `${Math.floor(d.year_built / 10) * 10}s`;
                        if (!occupancyGroups[d.OCC_CLS][decade]) {
                            occupancyGroups[d.OCC_CLS][decade] = 0;
                        }
                        occupancyGroups[d.OCC_CLS][decade]++;
                    });
                    
                    Object.keys(occupancyGroups).forEach(occ => {
                        sunburstLabels.push(occ);
                        sunburstParents.push('Buildings');
                        sunburstValues.push(Object.values(occupancyGroups[occ]).reduce((a, b) => a + b, 0));
                        
                        Object.keys(occupancyGroups[occ]).forEach(decade => {
                            sunburstLabels.push(`${occ} - ${decade}`);
                            sunburstParents.push(occ);
                            sunburstValues.push(occupancyGroups[occ][decade]);
                        });
                    });
                    
                    plotData = [{
                        type: 'sunburst',
                        labels: sunburstLabels,
                        parents: sunburstParents,
                        values: sunburstValues,
                        branchvalues: 'total',
                        marker: {
                            colorscale: 'Plasma'
                        }
                    }];
                    
                    layout = {
                        title: 'Hierarchical Building Distribution',
                        height: 600
                    };
                    break;
                    
                case 'parallel':
                    plotData = [{
                        type: 'parcoords',
                        dimensions: [
                            {
                                label: 'Year',
                                values: filteredData.map(d => d.year_built),
                                range: [yearStart, yearEnd]
                            },
                            {
                                label: 'Est GFA',
                                values: filteredData.map(d => d['Est GFA sqmeters']),
                                range: [areaMin, areaMax]
                            },
                            {
                                label: 'Cluster',
                                values: filteredData.map(d => d.cluster),
                                range: [0, 6]
                            }
                        ],
                        line: {
                            color: filteredData.map(d => d.cluster),
                            colorscale: 'Plasma',
                            showscale: true
                        }
                    }];
                    
                    layout = {
                        title: 'Parallel Coordinates - Building Attributes',
                        height: 600
                    };
                    break;
                    
                case 'box':
                    const occupancies = [...new Set(filteredData.map(d => d.OCC_CLS))];
                    plotData = occupancies.map((occ, i) => ({
                        y: filteredData.filter(d => d.OCC_CLS === occ).map(d => d['Est GFA sqmeters']),
                        type: 'box',
                        name: occ,
                        boxpoints: 'outliers',
                        marker: { color: plasmaColors[i % plasmaColors.length] }
                    }));
                    
                    layout = {
                        title: 'Est GFA Distribution by Occupancy Class',
                        yaxis: { title: 'Est GFA sqmeters' },
                        height: 500
                    };
                    break;
                    
                case 'violin':
                    const violinOccupancies = [...new Set(filteredData.map(d => d.OCC_CLS))];
                    plotData = violinOccupancies.map((occ, index) => ({
                        y: filteredData.filter(d => d.OCC_CLS === occ).map(d => d['Est GFA sqmeters']),
                        type: 'violin',
                        name: occ,
                        box: { visible: true },
                        meanline: { visible: true },
                        fillcolor: plasmaColors[index % plasmaColors.length],
                        opacity: 0.6
                    }));
                    
                    layout = {
                        title: 'Est GFA Distribution (Violin Plot)',
                        yaxis: { title: 'Est GFA sqmeters' },
                        height: 500
                    };
                    break;
                    
                case 'treemap':
                    const treemapLabels = ['Root'];
                    const treemapParents = [''];
                    const treemapValues = [0];
                    
                    const treemapData = {};
                    filteredData.forEach(d => {
                        if (!treemapData[d.OCC_CLS]) {
                            treemapData[d.OCC_CLS] = 0;
                        }
                        treemapData[d.OCC_CLS]++;
                    });
                    
                    Object.entries(treemapData).forEach(([occ, count]) => {
                        treemapLabels.push(occ);
                        treemapParents.push('Root');
                        treemapValues.push(count);
                    });
                    
                    plotData = [{
                        type: 'treemap',
                        labels: treemapLabels,
                        parents: treemapParents,
                        values: treemapValues,
                        textinfo: "label+value+percent root",
                        marker: {
                            colorscale: 'Plasma'
                        }
                    }];
                    
                    layout = {
                        title: 'Building Distribution Treemap',
                        height: 600
                    };
                    break;
            }
            
            Plotly.newPlot('interactiveChart', plotData, layout, {responsive: true});
        }
        
        function exportChart(chartId, filename) {
            Plotly.downloadImage(chartId, {
                format: 'png',
                width: 1200,
                height: 800,
                filename: filename || 'chart'
            });
        }
        
        function exportAllData() {
            if (!buildingData) {
                alert('No data available to export');
                return;
            }
            
            const dataStr = JSON.stringify(buildingData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'building_analysis_data.json';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>